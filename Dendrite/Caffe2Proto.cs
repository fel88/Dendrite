// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: caffe2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Caffe2
{

    /// <summary>Holder for reflection information generated from caffe2.proto</summary>
    public static partial class Caffe2Reflection
    {

        #region Descriptor
        /// <summary>File descriptor for caffe2.proto</summary>
        public static pbr::FileDescriptor Descriptor
        {
            get { return descriptor; }
        }
        private static pbr::FileDescriptor descriptor;

        static Caffe2Reflection()
        {
            byte[] descriptorData = global::System.Convert.FromBase64String(
                string.Concat(
                  "CgxjYWZmZTIucHJvdG8SBmNhZmZlMiLhAQoRRXh0ZXJuYWxEYXRhUHJvdG8S",
                  "SwoLc291cmNlX3R5cGUYASABKA4yJC5jYWZmZTIuRXh0ZXJuYWxEYXRhUHJv",
                  "dG8uU291cmNlVHlwZToQSU5MSU5FX0NPTlRBSU5FUhIRCglyZWNvcmRfaWQY",
                  "AiABKAkSEwoLcmVjb3JkX3NpemUYBSABKAQSEQoGb2Zmc2V0GAMgASgDOgEw",
                  "Eg8KB3N0cmlkZXMYBCADKAMiMwoKU291cmNlVHlwZRIUChBJTkxJTkVfQ09O",
                  "VEFJTkVSEAASDwoLU0lNUExFX0ZJTEUQASLqBQoLVGVuc29yUHJvdG8SDAoE",
                  "ZGltcxgBIAMoAxI2CglkYXRhX3R5cGUYAiABKA4yHC5jYWZmZTIuVGVuc29y",
                  "UHJvdG8uRGF0YVR5cGU6BUZMT0FUEjwKDHN0b3JhZ2VfdHlwZRgMIAEoDjIf",
                  "LmNhZmZlMi5UZW5zb3JQcm90by5TdG9yYWdlVHlwZToFVFlQRUQSFgoKZmxv",
                  "YXRfZGF0YRgDIAMoAkICEAESFgoKaW50MzJfZGF0YRgEIAMoBUICEAESEQoJ",
                  "Ynl0ZV9kYXRhGAUgASgMEhMKC3N0cmluZ19kYXRhGAYgAygMEhcKC2RvdWJs",
                  "ZV9kYXRhGAkgAygBQgIQARIWCgppbnQ2NF9kYXRhGAogAygDQgIQARIQCghy",
                  "YXdfZGF0YRgNIAEoDBIwCg1leHRlcm5hbF9kYXRhGA4gASgLMhkuY2FmZmUy",
                  "LkV4dGVybmFsRGF0YVByb3RvEgwKBG5hbWUYByABKAkSKwoNZGV2aWNlX2Rl",
                  "dGFpbBgIIAEoCzIULmNhZmZlMi5EZXZpY2VPcHRpb24SLAoHc2VnbWVudBgL",
                  "IAEoCzIbLmNhZmZlMi5UZW5zb3JQcm90by5TZWdtZW50GiUKB1NlZ21lbnQS",
                  "DQoFYmVnaW4YASACKAMSCwoDZW5kGAIgAigDIrgBCghEYXRhVHlwZRINCglV",
                  "TkRFRklORUQQABIJCgVGTE9BVBABEgkKBUlOVDMyEAISCAoEQllURRADEgoK",
                  "BlNUUklORxAEEggKBEJPT0wQBRIJCgVVSU5UOBAGEggKBElOVDgQBxIKCgZV",
                  "SU5UMTYQCBIJCgVJTlQxNhAJEgkKBUlOVDY0EAoSCwoHRkxPQVQxNhAMEgoK",
                  "BkRPVUJMRRANEhcKE1pFUk9fQ09MTElTSU9OX0hBU0gQDiI/CgtTdG9yYWdl",
                  "VHlwZRIJCgVUWVBFRBABEgcKA1JBVxACEgwKCEVYVEVSTkFMEAMSDgoKTk9f",
                  "Q09OVEVOVBAEIoMCCgxRVGVuc29yUHJvdG8SDAoEZGltcxgBIAMoAxIRCglw",
                  "cmVjaXNpb24YAiACKAUSDQoFc2NhbGUYAyACKAESDAoEYmlhcxgEIAIoARIR",
                  "Cglpc19zaWduZWQYBSACKAgSEAoEZGF0YRgGIAMoBUICEAESDAoEbmFtZRgH",
                  "IAEoCRI2CglkYXRhX3R5cGUYCCABKA4yHC5jYWZmZTIuVGVuc29yUHJvdG8u",
                  "RGF0YVR5cGU6BUlOVDMyEg4KBnNjYWxlcxgJIAMoARIOCgZiaWFzZXMYCiAD",
                  "KAESDAoEYXhpcxgLIAEoBRIcCg1pc19tdWx0aXBhcmFtGAwgASgIOgVmYWxz",
                  "ZSIzCgxUZW5zb3JQcm90b3MSIwoGcHJvdG9zGAEgAygLMhMuY2FmZmUyLlRl",
                  "bnNvclByb3RvIpUBCgtUZW5zb3JTaGFwZRIMCgRkaW1zGAEgAygDEjYKCWRh",
                  "dGFfdHlwZRgCIAEoDjIcLmNhZmZlMi5UZW5zb3JQcm90by5EYXRhVHlwZToF",
                  "RkxPQVQSFAoMdW5rbm93bl9kaW1zGAMgAygFEhwKDXVua25vd25fc2hhcGUY",
                  "BCABKAg6BWZhbHNlEgwKBG5hbWUYBSABKAkiMwoMVGVuc29yU2hhcGVzEiMK",
                  "BnNoYXBlcxgBIAMoCzITLmNhZmZlMi5UZW5zb3JTaGFwZSKoAgoQVGVuc29y",
                  "Qm91bmRTaGFwZRIiCgVzaGFwZRgBIAEoCzITLmNhZmZlMi5UZW5zb3JTaGFw",
                  "ZRIyCghkaW1fdHlwZRgCIAMoDjIgLmNhZmZlMi5UZW5zb3JCb3VuZFNoYXBl",
                  "LkRpbVR5cGUSDAoEbmFtZRgDIAEoCRIWCg5zaGFwZV9pc19maW5hbBgEIAEo",
                  "CCKVAQoHRGltVHlwZRILCgdVTktOT1dOEAASDAoIQ09OU1RBTlQQARIJCgVC",
                  "QVRDSBACEhgKFEJBVENIX09GX0ZFQVRVUkVfTUFYEAMSIAocQkFUQ0hfT0Zf",
                  "RkVBVFVSRV9NQVhfREVGQVVMVBAEEg8KC0ZFQVRVUkVfTUFYEAUSFwoTRkVB",
                  "VFVSRV9NQVhfREVGQVVMVBAGIm4KEVRlbnNvckJvdW5kU2hhcGVzEigKBnNo",
                  "YXBlcxgBIAMoCzIYLmNhZmZlMi5UZW5zb3JCb3VuZFNoYXBlEhYKDm1heF9i",
                  "YXRjaF9zaXplGAIgASgDEhcKD21heF9mZWF0dXJlX2xlbhgDIAEoAyJVCglB",
                  "T1RDb25maWcSFgoObWF4X2JhdGNoX3NpemUYASACKAMSFAoMbWF4X3NlcV9z",
                  "aXplGAIgAigDEhoKEmluX2JhdGNoX2Jyb2FkY2FzdBgDIAIoCCKPAgoIQXJn",
                  "dW1lbnQSDAoEbmFtZRgBIAEoCRIJCgFmGAIgASgCEgkKAWkYAyABKAMSCQoB",
                  "cxgEIAEoDBIeCgF0GAogASgLMhMuY2FmZmUyLlRlbnNvclByb3RvEhkKAW4Y",
                  "CCABKAsyDi5jYWZmZTIuTmV0RGVmEg4KBmZsb2F0cxgFIAMoAhIMCgRpbnRz",
                  "GAYgAygDEg8KB3N0cmluZ3MYByADKAwSJAoHdGVuc29ycxgLIAMoCzITLmNh",
                  "ZmZlMi5UZW5zb3JQcm90bxIcCgRuZXRzGAkgAygLMg4uY2FmZmUyLk5ldERl",
                  "ZhImCghxdGVuc29ycxgMIAMoCzIULmNhZmZlMi5RVGVuc29yUHJvdG8iiwEK",
                  "DERldmljZU9wdGlvbhIWCgtkZXZpY2VfdHlwZRgBIAEoBToBMBIRCglkZXZp",
                  "Y2VfaWQYAiABKAUSEwoLcmFuZG9tX3NlZWQYAyABKA0SEQoJbm9kZV9uYW1l",
                  "GAQgASgJEhQKDG51bWFfbm9kZV9pZBgFIAEoBRISCgpleHRyYV9pbmZvGAYg",
                  "AygJIpICCgtPcGVyYXRvckRlZhINCgVpbnB1dBgBIAMoCRIOCgZvdXRwdXQY",
                  "AiADKAkSDAoEbmFtZRgDIAEoCRIMCgR0eXBlGAQgASgJEh0KA2FyZxgFIAMo",
                  "CzIQLmNhZmZlMi5Bcmd1bWVudBIrCg1kZXZpY2Vfb3B0aW9uGAYgASgLMhQu",
                  "Y2FmZmUyLkRldmljZU9wdGlvbhIOCgZlbmdpbmUYByABKAkSFQoNY29udHJv",
                  "bF9pbnB1dBgIIAMoCRIdCg5pc19ncmFkaWVudF9vcBgJIAEoCDoFZmFsc2US",
                  "EgoKZGVidWdfaW5mbxgKIAEoCRIOCgZkb21haW4YCyABKAkSEgoKb3BfdmVy",
                  "c2lvbhgMIAEoAyIpCg1NYXBGaWVsZEVudHJ5EgsKA2tleRgBIAIoCRILCgN2",
                  "YWwYAiACKAkiTQoOQmFja2VuZE9wdGlvbnMSFAoMYmFja2VuZF9uYW1lGAEg",
                  "AigJEiUKBm9wdGlvbhgCIAMoCzIVLmNhZmZlMi5NYXBGaWVsZEVudHJ5InUK",
                  "DVBhcnRpdGlvbkluZm8SDAoEbmFtZRgBIAIoCRIRCglkZXZpY2VfaWQYAiAD",
                  "KAUSEgoKZXh0cmFfaW5mbxgDIAEoCRIvCg9iYWNrZW5kX29wdGlvbnMYBCAD",
                  "KAsyFi5jYWZmZTIuQmFja2VuZE9wdGlvbnMihgIKBk5ldERlZhIMCgRuYW1l",
                  "GAEgASgJEh8KAm9wGAIgAygLMhMuY2FmZmUyLk9wZXJhdG9yRGVmEgwKBHR5",
                  "cGUYAyABKAkSEwoLbnVtX3dvcmtlcnMYBCABKAUSKwoNZGV2aWNlX29wdGlv",
                  "bhgFIAEoCzIULmNhZmZlMi5EZXZpY2VPcHRpb24SHQoDYXJnGAYgAygLMhAu",
                  "Y2FmZmUyLkFyZ3VtZW50EhYKDmV4dGVybmFsX2lucHV0GAcgAygJEhcKD2V4",
                  "dGVybmFsX291dHB1dBgIIAMoCRItCg5wYXJ0aXRpb25faW5mbxgJIAMoCzIV",
                  "LmNhZmZlMi5QYXJ0aXRpb25JbmZvIs8CCg1FeGVjdXRpb25TdGVwEgwKBG5h",
                  "bWUYASABKAkSJgoHc3Vic3RlcBgCIAMoCzIVLmNhZmZlMi5FeGVjdXRpb25T",
                  "dGVwEg8KB25ldHdvcmsYAyADKAkSEAoIbnVtX2l0ZXIYBCABKAMSHAoQY3Jp",
                  "dGVyaWFfbmV0d29yaxgFIAEoCUICGAESEgoKcmVwb3J0X25ldBgHIAEoCRIX",
                  "Cg9yZXBvcnRfaW50ZXJ2YWwYCCABKAUSFAoMcnVuX2V2ZXJ5X21zGAsgASgD",
                  "EhsKE2NvbmN1cnJlbnRfc3Vic3RlcHMYBiABKAgSGAoQc2hvdWxkX3N0b3Bf",
                  "YmxvYhgJIAEoCRIRCglvbmx5X29uY2UYCiABKAgSGAoQY3JlYXRlX3dvcmtz",
                  "cGFjZRgMIAEoCBIgChhudW1fY29uY3VycmVudF9pbnN0YW5jZXMYDSABKAUi",
                  "ZwoHUGxhbkRlZhIMCgRuYW1lGAEgASgJEh8KB25ldHdvcmsYAiADKAsyDi5j",
                  "YWZmZTIuTmV0RGVmEi0KDmV4ZWN1dGlvbl9zdGVwGAMgAygLMhUuY2FmZmUy",
                  "LkV4ZWN1dGlvblN0ZXAiugEKCUJsb2JQcm90bxIMCgRuYW1lGAEgASgJEgwK",
                  "BHR5cGUYAiABKAkSIwoGdGVuc29yGAMgASgLMhMuY2FmZmUyLlRlbnNvclBy",
                  "b3RvEg8KB2NvbnRlbnQYBCABKAwSJQoHcXRlbnNvchgFIAEoCzIULmNhZmZl",
                  "Mi5RVGVuc29yUHJvdG8SGgoSY29udGVudF9udW1fY2h1bmtzGAYgASgFEhgK",
                  "EGNvbnRlbnRfY2h1bmtfaWQYByABKAUiSwoNREJSZWFkZXJQcm90bxIMCgRu",
                  "YW1lGAEgASgJEg4KBnNvdXJjZRgCIAEoCRIPCgdkYl90eXBlGAMgASgJEgsK",
                  "A2tleRgEIAEoCSr6AQoPRGV2aWNlVHlwZVByb3RvEg0KCVBST1RPX0NQVRAA",
                  "Eg4KClBST1RPX0NVREEQARIQCgxQUk9UT19NS0xETk4QAhIQCgxQUk9UT19P",
                  "UEVOR0wQAxIQCgxQUk9UT19PUEVOQ0wQBBIPCgtQUk9UT19JREVFUBAFEg0K",
                  "CVBST1RPX0hJUBAGEg4KClBST1RPX0ZQR0EQBxIPCgtQUk9UT19NU05QVRAI",
                  "Eg0KCVBST1RPX1hMQRAJEicKI1BST1RPX0NPTVBJTEVfVElNRV9NQVhfREVW",
                  "SUNFX1RZUEVTEAoSGQoTUFJPVE9fT05MWV9GT1JfVEVTVBClowE="));
            descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
                new pbr::FileDescriptor[] { },
                new pbr::GeneratedClrTypeInfo(new[] { typeof(global::Caffe2.DeviceTypeProto), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.ExternalDataProto), global::Caffe2.ExternalDataProto.Parser, new[]{ "SourceType", "RecordId", "RecordSize", "Offset", "Strides" }, null, new[]{ typeof(global::Caffe2.ExternalDataProto.Types.SourceType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.TensorProto), global::Caffe2.TensorProto.Parser, new[]{ "Dims", "DataType", "StorageType", "FloatData", "Int32Data", "ByteData", "StringData", "DoubleData", "Int64Data", "RawData", "ExternalData", "Name", "DeviceDetail", "Segment" }, null, new[]{ typeof(global::Caffe2.TensorProto.Types.DataType), typeof(global::Caffe2.TensorProto.Types.StorageType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.TensorProto.Types.Segment), global::Caffe2.TensorProto.Types.Segment.Parser, new[]{ "Begin", "End" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.QTensorProto), global::Caffe2.QTensorProto.Parser, new[]{ "Dims", "Precision", "Scale", "Bias", "IsSigned", "Data", "Name", "DataType", "Scales", "Biases", "Axis", "IsMultiparam" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.TensorProtos), global::Caffe2.TensorProtos.Parser, new[]{ "Protos" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.TensorShape), global::Caffe2.TensorShape.Parser, new[]{ "Dims", "DataType", "UnknownDims", "UnknownShape", "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.TensorShapes), global::Caffe2.TensorShapes.Parser, new[]{ "Shapes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.TensorBoundShape), global::Caffe2.TensorBoundShape.Parser, new[]{ "Shape", "DimType", "Name", "ShapeIsFinal" }, null, new[]{ typeof(global::Caffe2.TensorBoundShape.Types.DimType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.TensorBoundShapes), global::Caffe2.TensorBoundShapes.Parser, new[]{ "Shapes", "MaxBatchSize", "MaxFeatureLen" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.AOTConfig), global::Caffe2.AOTConfig.Parser, new[]{ "MaxBatchSize", "MaxSeqSize", "InBatchBroadcast" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.Argument), global::Caffe2.Argument.Parser, new[]{ "Name", "F", "I", "S", "T", "N", "Floats", "Ints", "Strings", "Tensors", "Nets", "Qtensors" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.DeviceOption), global::Caffe2.DeviceOption.Parser, new[]{ "DeviceType", "DeviceId", "RandomSeed", "NodeName", "NumaNodeId", "ExtraInfo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.OperatorDef), global::Caffe2.OperatorDef.Parser, new[]{ "Input", "Output", "Name", "Type", "Arg", "DeviceOption", "Engine", "ControlInput", "IsGradientOp", "DebugInfo", "Domain", "OpVersion" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.MapFieldEntry), global::Caffe2.MapFieldEntry.Parser, new[]{ "Key", "Val" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.BackendOptions), global::Caffe2.BackendOptions.Parser, new[]{ "BackendName", "Option" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.PartitionInfo), global::Caffe2.PartitionInfo.Parser, new[]{ "Name", "DeviceId", "ExtraInfo", "BackendOptions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.NetDef), global::Caffe2.NetDef.Parser, new[]{ "Name", "Op", "Type", "NumWorkers", "DeviceOption", "Arg", "ExternalInput", "ExternalOutput", "PartitionInfo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.ExecutionStep), global::Caffe2.ExecutionStep.Parser, new[]{ "Name", "Substep", "Network", "NumIter", "CriteriaNetwork", "ReportNet", "ReportInterval", "RunEveryMs", "ConcurrentSubsteps", "ShouldStopBlob", "OnlyOnce", "CreateWorkspace", "NumConcurrentInstances" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.PlanDef), global::Caffe2.PlanDef.Parser, new[]{ "Name", "Network", "ExecutionStep" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.BlobProto), global::Caffe2.BlobProto.Parser, new[]{ "Name", "Type", "Tensor", "Content", "Qtensor", "ContentNumChunks", "ContentChunkId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Caffe2.DBReaderProto), global::Caffe2.DBReaderProto.Parser, new[]{ "Name", "Source", "DbType", "Key" }, null, null, null, null)
                }));
        }
        #endregion

    }
    #region Enums
    /// <summary>
    /// DeviceType that Caffe2 currently supports.
    /// Note: if you add a device type, make sure you add the corresponding device
    /// line in the DeviceTypeName() function in caffe2/utils/proto_utils.cc
    /// and update c10/core/DeviceType.h
    /// </summary>
    public enum DeviceTypeProto
    {
        /// <summary>
        /// In default, we will use CPU.
        /// </summary>
        [pbr::OriginalName("PROTO_CPU")] ProtoCpu = 0,
        /// <summary>
        /// CUDA.
        /// </summary>
        [pbr::OriginalName("PROTO_CUDA")] ProtoCuda = 1,
        /// <summary>
        /// Reserved for explicit MKLDNN
        /// </summary>
        [pbr::OriginalName("PROTO_MKLDNN")] ProtoMkldnn = 2,
        /// <summary>
        /// OpenGL
        /// </summary>
        [pbr::OriginalName("PROTO_OPENGL")] ProtoOpengl = 3,
        /// <summary>
        /// OpenCL
        /// </summary>
        [pbr::OriginalName("PROTO_OPENCL")] ProtoOpencl = 4,
        /// <summary>
        /// IDEEP.
        /// </summary>
        [pbr::OriginalName("PROTO_IDEEP")] ProtoIdeep = 5,
        /// <summary>
        /// AMD HIP
        /// </summary>
        [pbr::OriginalName("PROTO_HIP")] ProtoHip = 6,
        /// <summary>
        /// FPGA
        /// </summary>
        [pbr::OriginalName("PROTO_FPGA")] ProtoFpga = 7,
        /// <summary>
        /// MSNPU
        /// </summary>
        [pbr::OriginalName("PROTO_MSNPU")] ProtoMsnpu = 8,
        /// <summary>
        /// XLA / TPU
        /// </summary>
        [pbr::OriginalName("PROTO_XLA")] ProtoXla = 9,
        /// <summary>
        /// Change the following number if you add more devices in the code.
        /// </summary>
        [pbr::OriginalName("PROTO_COMPILE_TIME_MAX_DEVICE_TYPES")] ProtoCompileTimeMaxDeviceTypes = 10,
        /// <summary>
        /// This device type is only for test.
        /// </summary>
        [pbr::OriginalName("PROTO_ONLY_FOR_TEST")] ProtoOnlyForTest = 20901,
    }

    #endregion

    #region Messages
    /// <summary>
    /// ExternalDataProto stores the pointer to the content of TensorProto
    /// the content are stored in the raw format as little endian
    /// </summary>
    public sealed partial class ExternalDataProto : pb::IMessage<ExternalDataProto>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<ExternalDataProto> _parser = new pb::MessageParser<ExternalDataProto>(() => new ExternalDataProto());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ExternalDataProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExternalDataProto()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExternalDataProto(ExternalDataProto other) : this()
        {
            _hasBits0 = other._hasBits0;
            sourceType_ = other.sourceType_;
            recordId_ = other.recordId_;
            recordSize_ = other.recordSize_;
            offset_ = other.offset_;
            strides_ = other.strides_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExternalDataProto Clone()
        {
            return new ExternalDataProto(this);
        }

        /// <summary>Field number for the "source_type" field.</summary>
        public const int SourceTypeFieldNumber = 1;
        private readonly static global::Caffe2.ExternalDataProto.Types.SourceType SourceTypeDefaultValue = global::Caffe2.ExternalDataProto.Types.SourceType.InlineContainer;

        private global::Caffe2.ExternalDataProto.Types.SourceType sourceType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.ExternalDataProto.Types.SourceType SourceType
        {
            get { if ((_hasBits0 & 1) != 0) { return sourceType_; } else { return SourceTypeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                sourceType_ = value;
            }
        }
        /// <summary>Gets whether the "source_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasSourceType
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "source_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearSourceType()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "record_id" field.</summary>
        public const int RecordIdFieldNumber = 2;
        private readonly static string RecordIdDefaultValue = "";

        private string recordId_;
        /// <summary>
        /// used together with type
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string RecordId
        {
            get { return recordId_ ?? RecordIdDefaultValue; }
            set
            {
                recordId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "record_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasRecordId
        {
            get { return recordId_ != null; }
        }
        /// <summary>Clears the value of the "record_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearRecordId()
        {
            recordId_ = null;
        }

        /// <summary>Field number for the "record_size" field.</summary>
        public const int RecordSizeFieldNumber = 5;
        private readonly static ulong RecordSizeDefaultValue = 0UL;

        private ulong recordSize_;
        /// <summary>
        /// the size of the entire record (in bytes)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong RecordSize
        {
            get { if ((_hasBits0 & 4) != 0) { return recordSize_; } else { return RecordSizeDefaultValue; } }
            set
            {
                _hasBits0 |= 4;
                recordSize_ = value;
            }
        }
        /// <summary>Gets whether the "record_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasRecordSize
        {
            get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "record_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearRecordSize()
        {
            _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "offset" field.</summary>
        public const int OffsetFieldNumber = 3;
        private readonly static long OffsetDefaultValue = 0L;

        private long offset_;
        /// <summary>
        /// the offset of the starting point, the content may be shared between
        /// multiple tensors
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Offset
        {
            get { if ((_hasBits0 & 2) != 0) { return offset_; } else { return OffsetDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                offset_ = value;
            }
        }
        /// <summary>Gets whether the "offset" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasOffset
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "offset" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearOffset()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "strides" field.</summary>
        public const int StridesFieldNumber = 4;
        private static readonly pb::FieldCodec<long> _repeated_strides_codec
            = pb::FieldCodec.ForInt64(32);
        private readonly pbc::RepeatedField<long> strides_ = new pbc::RepeatedField<long>();
        /// <summary>
        /// the strides of the content
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Strides
        {
            get { return strides_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as ExternalDataProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ExternalDataProto other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (SourceType != other.SourceType) return false;
            if (RecordId != other.RecordId) return false;
            if (RecordSize != other.RecordSize) return false;
            if (Offset != other.Offset) return false;
            if (!strides_.Equals(other.strides_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasSourceType) hash ^= SourceType.GetHashCode();
            if (HasRecordId) hash ^= RecordId.GetHashCode();
            if (HasRecordSize) hash ^= RecordSize.GetHashCode();
            if (HasOffset) hash ^= Offset.GetHashCode();
            hash ^= strides_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasSourceType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) SourceType);
      }
      if (HasRecordId) {
        output.WriteRawTag(18);
        output.WriteString(RecordId);
      }
      if (HasOffset) {
        output.WriteRawTag(24);
        output.WriteInt64(Offset);
      }
      strides_.WriteTo(output, _repeated_strides_codec);
      if (HasRecordSize) {
        output.WriteRawTag(40);
        output.WriteUInt64(RecordSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasSourceType)
            {
                output.WriteRawTag(8);
                output.WriteEnum((int)SourceType);
            }
            if (HasRecordId)
            {
                output.WriteRawTag(18);
                output.WriteString(RecordId);
            }
            if (HasOffset)
            {
                output.WriteRawTag(24);
                output.WriteInt64(Offset);
            }
            strides_.WriteTo(ref output, _repeated_strides_codec);
            if (HasRecordSize)
            {
                output.WriteRawTag(40);
                output.WriteUInt64(RecordSize);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasSourceType)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)SourceType);
            }
            if (HasRecordId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(RecordId);
            }
            if (HasRecordSize)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(RecordSize);
            }
            if (HasOffset)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(Offset);
            }
            size += strides_.CalculateSize(_repeated_strides_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ExternalDataProto other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasSourceType)
            {
                SourceType = other.SourceType;
            }
            if (other.HasRecordId)
            {
                RecordId = other.RecordId;
            }
            if (other.HasRecordSize)
            {
                RecordSize = other.RecordSize;
            }
            if (other.HasOffset)
            {
                Offset = other.Offset;
            }
            strides_.Add(other.strides_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SourceType = (global::Caffe2.ExternalDataProto.Types.SourceType) input.ReadEnum();
            break;
          }
          case 18: {
            RecordId = input.ReadString();
            break;
          }
          case 24: {
            Offset = input.ReadInt64();
            break;
          }
          case 34:
          case 32: {
            strides_.AddEntriesFrom(input, _repeated_strides_codec);
            break;
          }
          case 40: {
            RecordSize = input.ReadUInt64();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 8:
                        {
                            SourceType = (global::Caffe2.ExternalDataProto.Types.SourceType)input.ReadEnum();
                            break;
                        }
                    case 18:
                        {
                            RecordId = input.ReadString();
                            break;
                        }
                    case 24:
                        {
                            Offset = input.ReadInt64();
                            break;
                        }
                    case 34:
                    case 32:
                        {
                            strides_.AddEntriesFrom(ref input, _repeated_strides_codec);
                            break;
                        }
                    case 40:
                        {
                            RecordSize = input.ReadUInt64();
                            break;
                        }
                }
            }
        }
#endif

        #region Nested types
        /// <summary>Container for nested types declared in the ExternalDataProto message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            /// <summary>
            /// type of the external storage type, can be the following:
            /// </summary>
            public enum SourceType
            {
                /// <summary>
                /// the container defined in torch/csrc/jit/serialization.h is used,
                /// and record_id is the tag to help the runtime identify the data
                /// this type of storage is set as DEFAULT and recommended for external
                /// data storage
                /// </summary>
                [pbr::OriginalName("INLINE_CONTAINER")] InlineContainer = 0,
                /// <summary>
                /// use external file to store the data, and record_id is the POSIX relative path
                /// to the file. this (simple) file is only for the data, and the data is stored
                /// as little endian in the file
                /// </summary>
                [pbr::OriginalName("SIMPLE_FILE")] SimpleFile = 1,
            }

        }
        #endregion

    }

    /// <summary>
    /// TensorProto stores serialized Tensor objects.
    /// </summary>
    public sealed partial class TensorProto : pb::IMessage<TensorProto>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TensorProto> _parser = new pb::MessageParser<TensorProto>(() => new TensorProto());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorProto()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorProto(TensorProto other) : this()
        {
            _hasBits0 = other._hasBits0;
            dims_ = other.dims_.Clone();
            dataType_ = other.dataType_;
            storageType_ = other.storageType_;
            floatData_ = other.floatData_.Clone();
            int32Data_ = other.int32Data_.Clone();
            byteData_ = other.byteData_;
            stringData_ = other.stringData_.Clone();
            doubleData_ = other.doubleData_.Clone();
            int64Data_ = other.int64Data_.Clone();
            rawData_ = other.rawData_;
            externalData_ = other.externalData_ != null ? other.externalData_.Clone() : null;
            name_ = other.name_;
            deviceDetail_ = other.deviceDetail_ != null ? other.deviceDetail_.Clone() : null;
            segment_ = other.segment_ != null ? other.segment_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorProto Clone()
        {
            return new TensorProto(this);
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 1;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(8);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        /// <summary>
        /// The dimensions in the tensor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Dims
        {
            get { return dims_; }
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 2;
        private readonly static global::Caffe2.TensorProto.Types.DataType DataTypeDefaultValue = global::Caffe2.TensorProto.Types.DataType.Float;

        private global::Caffe2.TensorProto.Types.DataType dataType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorProto.Types.DataType DataType
        {
            get { if ((_hasBits0 & 1) != 0) { return dataType_; } else { return DataTypeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                dataType_ = value;
            }
        }
        /// <summary>Gets whether the "data_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDataType
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "data_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDataType()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "storage_type" field.</summary>
        public const int StorageTypeFieldNumber = 12;
        private readonly static global::Caffe2.TensorProto.Types.StorageType StorageTypeDefaultValue = global::Caffe2.TensorProto.Types.StorageType.Typed;

        private global::Caffe2.TensorProto.Types.StorageType storageType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorProto.Types.StorageType StorageType
        {
            get { if ((_hasBits0 & 2) != 0) { return storageType_; } else { return StorageTypeDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                storageType_ = value;
            }
        }
        /// <summary>Gets whether the "storage_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasStorageType
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "storage_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearStorageType()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "float_data" field.</summary>
        public const int FloatDataFieldNumber = 3;
        private static readonly pb::FieldCodec<float> _repeated_floatData_codec
            = pb::FieldCodec.ForFloat(26);
        private readonly pbc::RepeatedField<float> floatData_ = new pbc::RepeatedField<float>();
        /// <summary>
        /// For float
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<float> FloatData
        {
            get { return floatData_; }
        }

        /// <summary>Field number for the "int32_data" field.</summary>
        public const int Int32DataFieldNumber = 4;
        private static readonly pb::FieldCodec<int> _repeated_int32Data_codec
            = pb::FieldCodec.ForInt32(34);
        private readonly pbc::RepeatedField<int> int32Data_ = new pbc::RepeatedField<int>();
        /// <summary>
        /// For int32, uint8, int8, uint16, int16, bool, and float16
        /// Note about float16: in storage we will basically convert float16 byte-wise
        /// to unsigned short and then store them in the int32_data field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<int> Int32Data
        {
            get { return int32Data_; }
        }

        /// <summary>Field number for the "byte_data" field.</summary>
        public const int ByteDataFieldNumber = 5;
        private readonly static pb::ByteString ByteDataDefaultValue = pb::ByteString.Empty;

        private pb::ByteString byteData_;
        /// <summary>
        /// For bytes
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString ByteData
        {
            get { return byteData_ ?? ByteDataDefaultValue; }
            set
            {
                byteData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "byte_data" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasByteData
        {
            get { return byteData_ != null; }
        }
        /// <summary>Clears the value of the "byte_data" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearByteData()
        {
            byteData_ = null;
        }

        /// <summary>Field number for the "string_data" field.</summary>
        public const int StringDataFieldNumber = 6;
        private static readonly pb::FieldCodec<pb::ByteString> _repeated_stringData_codec
            = pb::FieldCodec.ForBytes(50);
        private readonly pbc::RepeatedField<pb::ByteString> stringData_ = new pbc::RepeatedField<pb::ByteString>();
        /// <summary>
        /// For strings
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<pb::ByteString> StringData
        {
            get { return stringData_; }
        }

        /// <summary>Field number for the "double_data" field.</summary>
        public const int DoubleDataFieldNumber = 9;
        private static readonly pb::FieldCodec<double> _repeated_doubleData_codec
            = pb::FieldCodec.ForDouble(74);
        private readonly pbc::RepeatedField<double> doubleData_ = new pbc::RepeatedField<double>();
        /// <summary>
        /// For double
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<double> DoubleData
        {
            get { return doubleData_; }
        }

        /// <summary>Field number for the "int64_data" field.</summary>
        public const int Int64DataFieldNumber = 10;
        private static readonly pb::FieldCodec<long> _repeated_int64Data_codec
            = pb::FieldCodec.ForInt64(82);
        private readonly pbc::RepeatedField<long> int64Data_ = new pbc::RepeatedField<long>();
        /// <summary>
        /// For int64
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Int64Data
        {
            get { return int64Data_; }
        }

        /// <summary>Field number for the "raw_data" field.</summary>
        public const int RawDataFieldNumber = 13;
        private readonly static pb::ByteString RawDataDefaultValue = pb::ByteString.Empty;

        private pb::ByteString rawData_;
        /// <summary>
        /// store the raw data, contents are serialized as little-endian
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString RawData
        {
            get { return rawData_ ?? RawDataDefaultValue; }
            set
            {
                rawData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "raw_data" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasRawData
        {
            get { return rawData_ != null; }
        }
        /// <summary>Clears the value of the "raw_data" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearRawData()
        {
            rawData_ = null;
        }

        /// <summary>Field number for the "external_data" field.</summary>
        public const int ExternalDataFieldNumber = 14;
        private global::Caffe2.ExternalDataProto externalData_;
        /// <summary>
        /// store the pointer to the data
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.ExternalDataProto ExternalData
        {
            get { return externalData_; }
            set
            {
                externalData_ = value;
            }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 7;
        private readonly static string NameDefaultValue = "";

        private string name_;
        /// <summary>
        /// Optionally, a name for the tensor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "device_detail" field.</summary>
        public const int DeviceDetailFieldNumber = 8;
        private global::Caffe2.DeviceOption deviceDetail_;
        /// <summary>
        /// Optionally, a TensorProto can contain the details about the device that
        /// it was serialized from. This is useful in cases like snapshotting a whole
        /// workspace in a multi-GPU environment.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.DeviceOption DeviceDetail
        {
            get { return deviceDetail_; }
            set
            {
                deviceDetail_ = value;
            }
        }

        /// <summary>Field number for the "segment" field.</summary>
        public const int SegmentFieldNumber = 11;
        private global::Caffe2.TensorProto.Types.Segment segment_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorProto.Types.Segment Segment
        {
            get { return segment_; }
            set
            {
                segment_ = value;
            }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TensorProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorProto other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!dims_.Equals(other.dims_)) return false;
            if (DataType != other.DataType) return false;
            if (StorageType != other.StorageType) return false;
            if (!floatData_.Equals(other.floatData_)) return false;
            if (!int32Data_.Equals(other.int32Data_)) return false;
            if (ByteData != other.ByteData) return false;
            if (!stringData_.Equals(other.stringData_)) return false;
            if (!doubleData_.Equals(other.doubleData_)) return false;
            if (!int64Data_.Equals(other.int64Data_)) return false;
            if (RawData != other.RawData) return false;
            if (!object.Equals(ExternalData, other.ExternalData)) return false;
            if (Name != other.Name) return false;
            if (!object.Equals(DeviceDetail, other.DeviceDetail)) return false;
            if (!object.Equals(Segment, other.Segment)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= dims_.GetHashCode();
            if (HasDataType) hash ^= DataType.GetHashCode();
            if (HasStorageType) hash ^= StorageType.GetHashCode();
            hash ^= floatData_.GetHashCode();
            hash ^= int32Data_.GetHashCode();
            if (HasByteData) hash ^= ByteData.GetHashCode();
            hash ^= stringData_.GetHashCode();
            hash ^= doubleData_.GetHashCode();
            hash ^= int64Data_.GetHashCode();
            if (HasRawData) hash ^= RawData.GetHashCode();
            if (externalData_ != null) hash ^= ExternalData.GetHashCode();
            if (HasName) hash ^= Name.GetHashCode();
            if (deviceDetail_ != null) hash ^= DeviceDetail.GetHashCode();
            if (segment_ != null) hash ^= Segment.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      dims_.WriteTo(output, _repeated_dims_codec);
      if (HasDataType) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      floatData_.WriteTo(output, _repeated_floatData_codec);
      int32Data_.WriteTo(output, _repeated_int32Data_codec);
      if (HasByteData) {
        output.WriteRawTag(42);
        output.WriteBytes(ByteData);
      }
      stringData_.WriteTo(output, _repeated_stringData_codec);
      if (HasName) {
        output.WriteRawTag(58);
        output.WriteString(Name);
      }
      if (deviceDetail_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(DeviceDetail);
      }
      doubleData_.WriteTo(output, _repeated_doubleData_codec);
      int64Data_.WriteTo(output, _repeated_int64Data_codec);
      if (segment_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Segment);
      }
      if (HasStorageType) {
        output.WriteRawTag(96);
        output.WriteEnum((int) StorageType);
      }
      if (HasRawData) {
        output.WriteRawTag(106);
        output.WriteBytes(RawData);
      }
      if (externalData_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(ExternalData);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            dims_.WriteTo(ref output, _repeated_dims_codec);
            if (HasDataType)
            {
                output.WriteRawTag(16);
                output.WriteEnum((int)DataType);
            }
            floatData_.WriteTo(ref output, _repeated_floatData_codec);
            int32Data_.WriteTo(ref output, _repeated_int32Data_codec);
            if (HasByteData)
            {
                output.WriteRawTag(42);
                output.WriteBytes(ByteData);
            }
            stringData_.WriteTo(ref output, _repeated_stringData_codec);
            if (HasName)
            {
                output.WriteRawTag(58);
                output.WriteString(Name);
            }
            if (deviceDetail_ != null)
            {
                output.WriteRawTag(66);
                output.WriteMessage(DeviceDetail);
            }
            doubleData_.WriteTo(ref output, _repeated_doubleData_codec);
            int64Data_.WriteTo(ref output, _repeated_int64Data_codec);
            if (segment_ != null)
            {
                output.WriteRawTag(90);
                output.WriteMessage(Segment);
            }
            if (HasStorageType)
            {
                output.WriteRawTag(96);
                output.WriteEnum((int)StorageType);
            }
            if (HasRawData)
            {
                output.WriteRawTag(106);
                output.WriteBytes(RawData);
            }
            if (externalData_ != null)
            {
                output.WriteRawTag(114);
                output.WriteMessage(ExternalData);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += dims_.CalculateSize(_repeated_dims_codec);
            if (HasDataType)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)DataType);
            }
            if (HasStorageType)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)StorageType);
            }
            size += floatData_.CalculateSize(_repeated_floatData_codec);
            size += int32Data_.CalculateSize(_repeated_int32Data_codec);
            if (HasByteData)
            {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(ByteData);
            }
            size += stringData_.CalculateSize(_repeated_stringData_codec);
            size += doubleData_.CalculateSize(_repeated_doubleData_codec);
            size += int64Data_.CalculateSize(_repeated_int64Data_codec);
            if (HasRawData)
            {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(RawData);
            }
            if (externalData_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExternalData);
            }
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (deviceDetail_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeviceDetail);
            }
            if (segment_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Segment);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorProto other)
        {
            if (other == null)
            {
                return;
            }
            dims_.Add(other.dims_);
            if (other.HasDataType)
            {
                DataType = other.DataType;
            }
            if (other.HasStorageType)
            {
                StorageType = other.StorageType;
            }
            floatData_.Add(other.floatData_);
            int32Data_.Add(other.int32Data_);
            if (other.HasByteData)
            {
                ByteData = other.ByteData;
            }
            stringData_.Add(other.stringData_);
            doubleData_.Add(other.doubleData_);
            int64Data_.Add(other.int64Data_);
            if (other.HasRawData)
            {
                RawData = other.RawData;
            }
            if (other.externalData_ != null)
            {
                if (externalData_ == null)
                {
                    ExternalData = new global::Caffe2.ExternalDataProto();
                }
                ExternalData.MergeFrom(other.ExternalData);
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            if (other.deviceDetail_ != null)
            {
                if (deviceDetail_ == null)
                {
                    DeviceDetail = new global::Caffe2.DeviceOption();
                }
                DeviceDetail.MergeFrom(other.DeviceDetail);
            }
            if (other.segment_ != null)
            {
                if (segment_ == null)
                {
                    Segment = new global::Caffe2.TensorProto.Types.Segment();
                }
                Segment.MergeFrom(other.Segment);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 16: {
            DataType = (global::Caffe2.TensorProto.Types.DataType) input.ReadEnum();
            break;
          }
          case 26:
          case 29: {
            floatData_.AddEntriesFrom(input, _repeated_floatData_codec);
            break;
          }
          case 34:
          case 32: {
            int32Data_.AddEntriesFrom(input, _repeated_int32Data_codec);
            break;
          }
          case 42: {
            ByteData = input.ReadBytes();
            break;
          }
          case 50: {
            stringData_.AddEntriesFrom(input, _repeated_stringData_codec);
            break;
          }
          case 58: {
            Name = input.ReadString();
            break;
          }
          case 66: {
            if (deviceDetail_ == null) {
              DeviceDetail = new global::Caffe2.DeviceOption();
            }
            input.ReadMessage(DeviceDetail);
            break;
          }
          case 74:
          case 73: {
            doubleData_.AddEntriesFrom(input, _repeated_doubleData_codec);
            break;
          }
          case 82:
          case 80: {
            int64Data_.AddEntriesFrom(input, _repeated_int64Data_codec);
            break;
          }
          case 90: {
            if (segment_ == null) {
              Segment = new global::Caffe2.TensorProto.Types.Segment();
            }
            input.ReadMessage(Segment);
            break;
          }
          case 96: {
            StorageType = (global::Caffe2.TensorProto.Types.StorageType) input.ReadEnum();
            break;
          }
          case 106: {
            RawData = input.ReadBytes();
            break;
          }
          case 114: {
            if (externalData_ == null) {
              ExternalData = new global::Caffe2.ExternalDataProto();
            }
            input.ReadMessage(ExternalData);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                    case 8:
                        {
                            dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
                            break;
                        }
                    case 16:
                        {
                            DataType = (global::Caffe2.TensorProto.Types.DataType)input.ReadEnum();
                            break;
                        }
                    case 26:
                    case 29:
                        {
                            floatData_.AddEntriesFrom(ref input, _repeated_floatData_codec);
                            break;
                        }
                    case 34:
                    case 32:
                        {
                            int32Data_.AddEntriesFrom(ref input, _repeated_int32Data_codec);
                            break;
                        }
                    case 42:
                        {
                            ByteData = input.ReadBytes();
                            break;
                        }
                    case 50:
                        {
                            stringData_.AddEntriesFrom(ref input, _repeated_stringData_codec);
                            break;
                        }
                    case 58:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 66:
                        {
                            if (deviceDetail_ == null)
                            {
                                DeviceDetail = new global::Caffe2.DeviceOption();
                            }
                            input.ReadMessage(DeviceDetail);
                            break;
                        }
                    case 74:
                    case 73:
                        {
                            doubleData_.AddEntriesFrom(ref input, _repeated_doubleData_codec);
                            break;
                        }
                    case 82:
                    case 80:
                        {
                            int64Data_.AddEntriesFrom(ref input, _repeated_int64Data_codec);
                            break;
                        }
                    case 90:
                        {
                            if (segment_ == null)
                            {
                                Segment = new global::Caffe2.TensorProto.Types.Segment();
                            }
                            input.ReadMessage(Segment);
                            break;
                        }
                    case 96:
                        {
                            StorageType = (global::Caffe2.TensorProto.Types.StorageType)input.ReadEnum();
                            break;
                        }
                    case 106:
                        {
                            RawData = input.ReadBytes();
                            break;
                        }
                    case 114:
                        {
                            if (externalData_ == null)
                            {
                                ExternalData = new global::Caffe2.ExternalDataProto();
                            }
                            input.ReadMessage(ExternalData);
                            break;
                        }
                }
            }
        }
#endif

        #region Nested types
        /// <summary>Container for nested types declared in the TensorProto message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            /// <summary>
            /// Data type
            /// </summary>
            public enum DataType
            {
                [pbr::OriginalName("UNDEFINED")] Undefined = 0,
                /// <summary>
                /// Basic types
                /// </summary>
                [pbr::OriginalName("FLOAT")] Float = 1,
                /// <summary>
                /// int
                /// </summary>
                [pbr::OriginalName("INT32")] Int32 = 2,
                /// <summary>
                /// byte, when deserialized, is going to be restored as uint8
                /// </summary>
                [pbr::OriginalName("BYTE")] Byte = 3,
                /// <summary>
                /// string
                /// </summary>
                [pbr::OriginalName("STRING")] String = 4,
                /// <summary>
                /// Less-commonly used data types
                /// </summary>
                [pbr::OriginalName("BOOL")] Bool = 5,
                /// <summary>
                /// uint8_t
                /// </summary>
                [pbr::OriginalName("UINT8")] Uint8 = 6,
                /// <summary>
                /// int8_t
                /// </summary>
                [pbr::OriginalName("INT8")] Int8 = 7,
                /// <summary>
                /// uint16_t
                /// </summary>
                [pbr::OriginalName("UINT16")] Uint16 = 8,
                /// <summary>
                /// int16_t
                /// </summary>
                [pbr::OriginalName("INT16")] Int16 = 9,
                /// <summary>
                /// int64_t
                /// </summary>
                [pbr::OriginalName("INT64")] Int64 = 10,
                /// <summary>
                /// at::Half
                /// </summary>
                [pbr::OriginalName("FLOAT16")] Float16 = 12,
                /// <summary>
                /// double
                /// </summary>
                [pbr::OriginalName("DOUBLE")] Double = 13,
                /// <summary>
                /// zero-collision hash state
                /// </summary>
                [pbr::OriginalName("ZERO_COLLISION_HASH")] ZeroCollisionHash = 14,
            }

            /// <summary>
            /// data storage
            /// </summary>
            public enum StorageType
            {
                /// <summary>
                /// the content is stored in typed field, for example, if the data_type is
                /// FLOAT, float_data is used to store the content.
                /// </summary>
                [pbr::OriginalName("TYPED")] Typed = 1,
                /// <summary>
                /// the content is serialized in field raw_data as little-endian
                /// </summary>
                [pbr::OriginalName("RAW")] Raw = 2,
                /// <summary>
                /// the pointer to the content is stored in field external_data
                /// the content is serialized as little-endian
                /// </summary>
                [pbr::OriginalName("EXTERNAL")] External = 3,
                /// <summary>
                /// When StorageType is NO_CONTENT, we use TensorProto to store only type
                /// and shape information. Reuse TensorProto to store type and shape
                /// because we can just have one proto, not having another ValueInfoProto
                /// </summary>
                [pbr::OriginalName("NO_CONTENT")] NoContent = 4,
            }

            /// <summary>
            /// When loading from chunks this is going to indicate where to put data in the
            /// full array. When not used full data have to be present
            /// </summary>
            public sealed partial class Segment : pb::IMessage<Segment>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
#endif
            {
                private static readonly pb::MessageParser<Segment> _parser = new pb::MessageParser<Segment>(() => new Segment());
                private pb::UnknownFieldSet _unknownFields;
                private int _hasBits0;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pb::MessageParser<Segment> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pbr::MessageDescriptor Descriptor
                {
                    get { return global::Caffe2.TensorProto.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                pbr::MessageDescriptor pb::IMessage.Descriptor
                {
                    get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public Segment()
                {
                    OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public Segment(Segment other) : this()
                {
                    _hasBits0 = other._hasBits0;
                    begin_ = other.begin_;
                    end_ = other.end_;
                    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public Segment Clone()
                {
                    return new Segment(this);
                }

                /// <summary>Field number for the "begin" field.</summary>
                public const int BeginFieldNumber = 1;
                private readonly static long BeginDefaultValue = 0L;

                private long begin_;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public long Begin
                {
                    get { if ((_hasBits0 & 1) != 0) { return begin_; } else { return BeginDefaultValue; } }
                    set
                    {
                        _hasBits0 |= 1;
                        begin_ = value;
                    }
                }
                /// <summary>Gets whether the "begin" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool HasBegin
                {
                    get { return (_hasBits0 & 1) != 0; }
                }
                /// <summary>Clears the value of the "begin" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void ClearBegin()
                {
                    _hasBits0 &= ~1;
                }

                /// <summary>Field number for the "end" field.</summary>
                public const int EndFieldNumber = 2;
                private readonly static long EndDefaultValue = 0L;

                private long end_;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public long End
                {
                    get { if ((_hasBits0 & 2) != 0) { return end_; } else { return EndDefaultValue; } }
                    set
                    {
                        _hasBits0 |= 2;
                        end_ = value;
                    }
                }
                /// <summary>Gets whether the "end" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool HasEnd
                {
                    get { return (_hasBits0 & 2) != 0; }
                }
                /// <summary>Clears the value of the "end" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void ClearEnd()
                {
                    _hasBits0 &= ~2;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override bool Equals(object other)
                {
                    return Equals(other as Segment);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool Equals(Segment other)
                {
                    if (ReferenceEquals(other, null))
                    {
                        return false;
                    }
                    if (ReferenceEquals(other, this))
                    {
                        return true;
                    }
                    if (Begin != other.Begin) return false;
                    if (End != other.End) return false;
                    return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override int GetHashCode()
                {
                    int hash = 1;
                    if (HasBegin) hash ^= Begin.GetHashCode();
                    if (HasEnd) hash ^= End.GetHashCode();
                    if (_unknownFields != null)
                    {
                        hash ^= _unknownFields.GetHashCode();
                    }
                    return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override string ToString()
                {
                    return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void WriteTo(pb::CodedOutputStream output)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    output.WriteRawMessage(this);
#else
          if (HasBegin) {
            output.WriteRawTag(8);
            output.WriteInt64(Begin);
          }
          if (HasEnd) {
            output.WriteRawTag(16);
            output.WriteInt64(End);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
                {
                    if (HasBegin)
                    {
                        output.WriteRawTag(8);
                        output.WriteInt64(Begin);
                    }
                    if (HasEnd)
                    {
                        output.WriteRawTag(16);
                        output.WriteInt64(End);
                    }
                    if (_unknownFields != null)
                    {
                        _unknownFields.WriteTo(ref output);
                    }
                }
#endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public int CalculateSize()
                {
                    int size = 0;
                    if (HasBegin)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Begin);
                    }
                    if (HasEnd)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeInt64Size(End);
                    }
                    if (_unknownFields != null)
                    {
                        size += _unknownFields.CalculateSize();
                    }
                    return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(Segment other)
                {
                    if (other == null)
                    {
                        return;
                    }
                    if (other.HasBegin)
                    {
                        Begin = other.Begin;
                    }
                    if (other.HasEnd)
                    {
                        End = other.End;
                    }
                    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(pb::CodedInputStream input)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    input.ReadRawMessage(this);
#else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Begin = input.ReadInt64();
                break;
              }
              case 16: {
                End = input.ReadInt64();
                break;
              }
            }
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
                {
                    uint tag;
                    while ((tag = input.ReadTag()) != 0)
                    {
                        switch (tag)
                        {
                            default:
                                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                                break;
                            case 8:
                                {
                                    Begin = input.ReadInt64();
                                    break;
                                }
                            case 16:
                                {
                                    End = input.ReadInt64();
                                    break;
                                }
                        }
                    }
                }
#endif

            }

        }
        #endregion

    }

    public sealed partial class QTensorProto : pb::IMessage<QTensorProto>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<QTensorProto> _parser = new pb::MessageParser<QTensorProto>(() => new QTensorProto());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<QTensorProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public QTensorProto()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public QTensorProto(QTensorProto other) : this()
        {
            _hasBits0 = other._hasBits0;
            dims_ = other.dims_.Clone();
            precision_ = other.precision_;
            scale_ = other.scale_;
            bias_ = other.bias_;
            isSigned_ = other.isSigned_;
            data_ = other.data_.Clone();
            name_ = other.name_;
            dataType_ = other.dataType_;
            scales_ = other.scales_.Clone();
            biases_ = other.biases_.Clone();
            axis_ = other.axis_;
            isMultiparam_ = other.isMultiparam_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public QTensorProto Clone()
        {
            return new QTensorProto(this);
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 1;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(8);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Dims
        {
            get { return dims_; }
        }

        /// <summary>Field number for the "precision" field.</summary>
        public const int PrecisionFieldNumber = 2;
        private readonly static int PrecisionDefaultValue = 0;

        private int precision_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Precision
        {
            get { if ((_hasBits0 & 1) != 0) { return precision_; } else { return PrecisionDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                precision_ = value;
            }
        }
        /// <summary>Gets whether the "precision" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasPrecision
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "precision" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearPrecision()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "scale" field.</summary>
        public const int ScaleFieldNumber = 3;
        private readonly static double ScaleDefaultValue = 0D;

        private double scale_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Scale
        {
            get { if ((_hasBits0 & 2) != 0) { return scale_; } else { return ScaleDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                scale_ = value;
            }
        }
        /// <summary>Gets whether the "scale" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasScale
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "scale" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearScale()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "bias" field.</summary>
        public const int BiasFieldNumber = 4;
        private readonly static double BiasDefaultValue = 0D;

        private double bias_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Bias
        {
            get { if ((_hasBits0 & 4) != 0) { return bias_; } else { return BiasDefaultValue; } }
            set
            {
                _hasBits0 |= 4;
                bias_ = value;
            }
        }
        /// <summary>Gets whether the "bias" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasBias
        {
            get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "bias" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearBias()
        {
            _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "is_signed" field.</summary>
        public const int IsSignedFieldNumber = 5;
        private readonly static bool IsSignedDefaultValue = false;

        private bool isSigned_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsSigned
        {
            get { if ((_hasBits0 & 8) != 0) { return isSigned_; } else { return IsSignedDefaultValue; } }
            set
            {
                _hasBits0 |= 8;
                isSigned_ = value;
            }
        }
        /// <summary>Gets whether the "is_signed" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasIsSigned
        {
            get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "is_signed" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearIsSigned()
        {
            _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "data" field.</summary>
        public const int DataFieldNumber = 6;
        private static readonly pb::FieldCodec<int> _repeated_data_codec
            = pb::FieldCodec.ForInt32(50);
        private readonly pbc::RepeatedField<int> data_ = new pbc::RepeatedField<int>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<int> Data
        {
            get { return data_; }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 7;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 8;
        private readonly static global::Caffe2.TensorProto.Types.DataType DataTypeDefaultValue = global::Caffe2.TensorProto.Types.DataType.Int32;

        private global::Caffe2.TensorProto.Types.DataType dataType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorProto.Types.DataType DataType
        {
            get { if ((_hasBits0 & 16) != 0) { return dataType_; } else { return DataTypeDefaultValue; } }
            set
            {
                _hasBits0 |= 16;
                dataType_ = value;
            }
        }
        /// <summary>Gets whether the "data_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDataType
        {
            get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "data_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDataType()
        {
            _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "scales" field.</summary>
        public const int ScalesFieldNumber = 9;
        private static readonly pb::FieldCodec<double> _repeated_scales_codec
            = pb::FieldCodec.ForDouble(73);
        private readonly pbc::RepeatedField<double> scales_ = new pbc::RepeatedField<double>();
        /// <summary>
        /// Multi-group quantization params
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<double> Scales
        {
            get { return scales_; }
        }

        /// <summary>Field number for the "biases" field.</summary>
        public const int BiasesFieldNumber = 10;
        private static readonly pb::FieldCodec<double> _repeated_biases_codec
            = pb::FieldCodec.ForDouble(81);
        private readonly pbc::RepeatedField<double> biases_ = new pbc::RepeatedField<double>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<double> Biases
        {
            get { return biases_; }
        }

        /// <summary>Field number for the "axis" field.</summary>
        public const int AxisFieldNumber = 11;
        private readonly static int AxisDefaultValue = 0;

        private int axis_;
        /// <summary>
        /// Multi-group quantization needed, indicates in which dimension
        /// we do the "group wise quantization"
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Axis
        {
            get { if ((_hasBits0 & 32) != 0) { return axis_; } else { return AxisDefaultValue; } }
            set
            {
                _hasBits0 |= 32;
                axis_ = value;
            }
        }
        /// <summary>Gets whether the "axis" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasAxis
        {
            get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "axis" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearAxis()
        {
            _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "is_multiparam" field.</summary>
        public const int IsMultiparamFieldNumber = 12;
        private readonly static bool IsMultiparamDefaultValue = false;

        private bool isMultiparam_;
        /// <summary>
        /// It should be true if it is a multi-group quantization proto
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsMultiparam
        {
            get { if ((_hasBits0 & 64) != 0) { return isMultiparam_; } else { return IsMultiparamDefaultValue; } }
            set
            {
                _hasBits0 |= 64;
                isMultiparam_ = value;
            }
        }
        /// <summary>Gets whether the "is_multiparam" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasIsMultiparam
        {
            get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "is_multiparam" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearIsMultiparam()
        {
            _hasBits0 &= ~64;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as QTensorProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(QTensorProto other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!dims_.Equals(other.dims_)) return false;
            if (Precision != other.Precision) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Scale, other.Scale)) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Bias, other.Bias)) return false;
            if (IsSigned != other.IsSigned) return false;
            if (!data_.Equals(other.data_)) return false;
            if (Name != other.Name) return false;
            if (DataType != other.DataType) return false;
            if (!scales_.Equals(other.scales_)) return false;
            if (!biases_.Equals(other.biases_)) return false;
            if (Axis != other.Axis) return false;
            if (IsMultiparam != other.IsMultiparam) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= dims_.GetHashCode();
            if (HasPrecision) hash ^= Precision.GetHashCode();
            if (HasScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Scale);
            if (HasBias) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Bias);
            if (HasIsSigned) hash ^= IsSigned.GetHashCode();
            hash ^= data_.GetHashCode();
            if (HasName) hash ^= Name.GetHashCode();
            if (HasDataType) hash ^= DataType.GetHashCode();
            hash ^= scales_.GetHashCode();
            hash ^= biases_.GetHashCode();
            if (HasAxis) hash ^= Axis.GetHashCode();
            if (HasIsMultiparam) hash ^= IsMultiparam.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      dims_.WriteTo(output, _repeated_dims_codec);
      if (HasPrecision) {
        output.WriteRawTag(16);
        output.WriteInt32(Precision);
      }
      if (HasScale) {
        output.WriteRawTag(25);
        output.WriteDouble(Scale);
      }
      if (HasBias) {
        output.WriteRawTag(33);
        output.WriteDouble(Bias);
      }
      if (HasIsSigned) {
        output.WriteRawTag(40);
        output.WriteBool(IsSigned);
      }
      data_.WriteTo(output, _repeated_data_codec);
      if (HasName) {
        output.WriteRawTag(58);
        output.WriteString(Name);
      }
      if (HasDataType) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DataType);
      }
      scales_.WriteTo(output, _repeated_scales_codec);
      biases_.WriteTo(output, _repeated_biases_codec);
      if (HasAxis) {
        output.WriteRawTag(88);
        output.WriteInt32(Axis);
      }
      if (HasIsMultiparam) {
        output.WriteRawTag(96);
        output.WriteBool(IsMultiparam);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            dims_.WriteTo(ref output, _repeated_dims_codec);
            if (HasPrecision)
            {
                output.WriteRawTag(16);
                output.WriteInt32(Precision);
            }
            if (HasScale)
            {
                output.WriteRawTag(25);
                output.WriteDouble(Scale);
            }
            if (HasBias)
            {
                output.WriteRawTag(33);
                output.WriteDouble(Bias);
            }
            if (HasIsSigned)
            {
                output.WriteRawTag(40);
                output.WriteBool(IsSigned);
            }
            data_.WriteTo(ref output, _repeated_data_codec);
            if (HasName)
            {
                output.WriteRawTag(58);
                output.WriteString(Name);
            }
            if (HasDataType)
            {
                output.WriteRawTag(64);
                output.WriteEnum((int)DataType);
            }
            scales_.WriteTo(ref output, _repeated_scales_codec);
            biases_.WriteTo(ref output, _repeated_biases_codec);
            if (HasAxis)
            {
                output.WriteRawTag(88);
                output.WriteInt32(Axis);
            }
            if (HasIsMultiparam)
            {
                output.WriteRawTag(96);
                output.WriteBool(IsMultiparam);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += dims_.CalculateSize(_repeated_dims_codec);
            if (HasPrecision)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(Precision);
            }
            if (HasScale)
            {
                size += 1 + 8;
            }
            if (HasBias)
            {
                size += 1 + 8;
            }
            if (HasIsSigned)
            {
                size += 1 + 1;
            }
            size += data_.CalculateSize(_repeated_data_codec);
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (HasDataType)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)DataType);
            }
            size += scales_.CalculateSize(_repeated_scales_codec);
            size += biases_.CalculateSize(_repeated_biases_codec);
            if (HasAxis)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(Axis);
            }
            if (HasIsMultiparam)
            {
                size += 1 + 1;
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(QTensorProto other)
        {
            if (other == null)
            {
                return;
            }
            dims_.Add(other.dims_);
            if (other.HasPrecision)
            {
                Precision = other.Precision;
            }
            if (other.HasScale)
            {
                Scale = other.Scale;
            }
            if (other.HasBias)
            {
                Bias = other.Bias;
            }
            if (other.HasIsSigned)
            {
                IsSigned = other.IsSigned;
            }
            data_.Add(other.data_);
            if (other.HasName)
            {
                Name = other.Name;
            }
            if (other.HasDataType)
            {
                DataType = other.DataType;
            }
            scales_.Add(other.scales_);
            biases_.Add(other.biases_);
            if (other.HasAxis)
            {
                Axis = other.Axis;
            }
            if (other.HasIsMultiparam)
            {
                IsMultiparam = other.IsMultiparam;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 16: {
            Precision = input.ReadInt32();
            break;
          }
          case 25: {
            Scale = input.ReadDouble();
            break;
          }
          case 33: {
            Bias = input.ReadDouble();
            break;
          }
          case 40: {
            IsSigned = input.ReadBool();
            break;
          }
          case 50:
          case 48: {
            data_.AddEntriesFrom(input, _repeated_data_codec);
            break;
          }
          case 58: {
            Name = input.ReadString();
            break;
          }
          case 64: {
            DataType = (global::Caffe2.TensorProto.Types.DataType) input.ReadEnum();
            break;
          }
          case 74:
          case 73: {
            scales_.AddEntriesFrom(input, _repeated_scales_codec);
            break;
          }
          case 82:
          case 81: {
            biases_.AddEntriesFrom(input, _repeated_biases_codec);
            break;
          }
          case 88: {
            Axis = input.ReadInt32();
            break;
          }
          case 96: {
            IsMultiparam = input.ReadBool();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                    case 8:
                        {
                            dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
                            break;
                        }
                    case 16:
                        {
                            Precision = input.ReadInt32();
                            break;
                        }
                    case 25:
                        {
                            Scale = input.ReadDouble();
                            break;
                        }
                    case 33:
                        {
                            Bias = input.ReadDouble();
                            break;
                        }
                    case 40:
                        {
                            IsSigned = input.ReadBool();
                            break;
                        }
                    case 50:
                    case 48:
                        {
                            data_.AddEntriesFrom(ref input, _repeated_data_codec);
                            break;
                        }
                    case 58:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 64:
                        {
                            DataType = (global::Caffe2.TensorProto.Types.DataType)input.ReadEnum();
                            break;
                        }
                    case 74:
                    case 73:
                        {
                            scales_.AddEntriesFrom(ref input, _repeated_scales_codec);
                            break;
                        }
                    case 82:
                    case 81:
                        {
                            biases_.AddEntriesFrom(ref input, _repeated_biases_codec);
                            break;
                        }
                    case 88:
                        {
                            Axis = input.ReadInt32();
                            break;
                        }
                    case 96:
                        {
                            IsMultiparam = input.ReadBool();
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// TensorProtos stores multiple TensorProto objects in one single proto. This
    /// is useful for small tensors; For anything big, consider using a DB for
    /// storage.
    /// </summary>
    public sealed partial class TensorProtos : pb::IMessage<TensorProtos>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TensorProtos> _parser = new pb::MessageParser<TensorProtos>(() => new TensorProtos());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorProtos> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorProtos()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorProtos(TensorProtos other) : this()
        {
            protos_ = other.protos_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorProtos Clone()
        {
            return new TensorProtos(this);
        }

        /// <summary>Field number for the "protos" field.</summary>
        public const int ProtosFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Caffe2.TensorProto> _repeated_protos_codec
            = pb::FieldCodec.ForMessage(10, global::Caffe2.TensorProto.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.TensorProto> protos_ = new pbc::RepeatedField<global::Caffe2.TensorProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.TensorProto> Protos
        {
            get { return protos_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TensorProtos);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorProtos other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!protos_.Equals(other.protos_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= protos_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      protos_.WriteTo(output, _repeated_protos_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            protos_.WriteTo(ref output, _repeated_protos_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += protos_.CalculateSize(_repeated_protos_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorProtos other)
        {
            if (other == null)
            {
                return;
            }
            protos_.Add(other.protos_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            protos_.AddEntriesFrom(input, _repeated_protos_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            protos_.AddEntriesFrom(ref input, _repeated_protos_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    public sealed partial class TensorShape : pb::IMessage<TensorShape>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TensorShape> _parser = new pb::MessageParser<TensorShape>(() => new TensorShape());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorShape> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShape()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShape(TensorShape other) : this()
        {
            _hasBits0 = other._hasBits0;
            dims_ = other.dims_.Clone();
            dataType_ = other.dataType_;
            unknownDims_ = other.unknownDims_.Clone();
            unknownShape_ = other.unknownShape_;
            name_ = other.name_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShape Clone()
        {
            return new TensorShape(this);
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 1;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(8);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Dims
        {
            get { return dims_; }
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 2;
        private readonly static global::Caffe2.TensorProto.Types.DataType DataTypeDefaultValue = global::Caffe2.TensorProto.Types.DataType.Float;

        private global::Caffe2.TensorProto.Types.DataType dataType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorProto.Types.DataType DataType
        {
            get { if ((_hasBits0 & 1) != 0) { return dataType_; } else { return DataTypeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                dataType_ = value;
            }
        }
        /// <summary>Gets whether the "data_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDataType
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "data_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDataType()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "unknown_dims" field.</summary>
        public const int UnknownDimsFieldNumber = 3;
        private static readonly pb::FieldCodec<int> _repeated_unknownDims_codec
            = pb::FieldCodec.ForInt32(24);
        private readonly pbc::RepeatedField<int> unknownDims_ = new pbc::RepeatedField<int>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<int> UnknownDims
        {
            get { return unknownDims_; }
        }

        /// <summary>Field number for the "unknown_shape" field.</summary>
        public const int UnknownShapeFieldNumber = 4;
        private readonly static bool UnknownShapeDefaultValue = false;

        private bool unknownShape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool UnknownShape
        {
            get { if ((_hasBits0 & 2) != 0) { return unknownShape_; } else { return UnknownShapeDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                unknownShape_ = value;
            }
        }
        /// <summary>Gets whether the "unknown_shape" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasUnknownShape
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "unknown_shape" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearUnknownShape()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 5;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TensorShape);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorShape other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!dims_.Equals(other.dims_)) return false;
            if (DataType != other.DataType) return false;
            if (!unknownDims_.Equals(other.unknownDims_)) return false;
            if (UnknownShape != other.UnknownShape) return false;
            if (Name != other.Name) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= dims_.GetHashCode();
            if (HasDataType) hash ^= DataType.GetHashCode();
            hash ^= unknownDims_.GetHashCode();
            if (HasUnknownShape) hash ^= UnknownShape.GetHashCode();
            if (HasName) hash ^= Name.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      dims_.WriteTo(output, _repeated_dims_codec);
      if (HasDataType) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      unknownDims_.WriteTo(output, _repeated_unknownDims_codec);
      if (HasUnknownShape) {
        output.WriteRawTag(32);
        output.WriteBool(UnknownShape);
      }
      if (HasName) {
        output.WriteRawTag(42);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            dims_.WriteTo(ref output, _repeated_dims_codec);
            if (HasDataType)
            {
                output.WriteRawTag(16);
                output.WriteEnum((int)DataType);
            }
            unknownDims_.WriteTo(ref output, _repeated_unknownDims_codec);
            if (HasUnknownShape)
            {
                output.WriteRawTag(32);
                output.WriteBool(UnknownShape);
            }
            if (HasName)
            {
                output.WriteRawTag(42);
                output.WriteString(Name);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += dims_.CalculateSize(_repeated_dims_codec);
            if (HasDataType)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)DataType);
            }
            size += unknownDims_.CalculateSize(_repeated_unknownDims_codec);
            if (HasUnknownShape)
            {
                size += 1 + 1;
            }
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorShape other)
        {
            if (other == null)
            {
                return;
            }
            dims_.Add(other.dims_);
            if (other.HasDataType)
            {
                DataType = other.DataType;
            }
            unknownDims_.Add(other.unknownDims_);
            if (other.HasUnknownShape)
            {
                UnknownShape = other.UnknownShape;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 16: {
            DataType = (global::Caffe2.TensorProto.Types.DataType) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            unknownDims_.AddEntriesFrom(input, _repeated_unknownDims_codec);
            break;
          }
          case 32: {
            UnknownShape = input.ReadBool();
            break;
          }
          case 42: {
            Name = input.ReadString();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                    case 8:
                        {
                            dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
                            break;
                        }
                    case 16:
                        {
                            DataType = (global::Caffe2.TensorProto.Types.DataType)input.ReadEnum();
                            break;
                        }
                    case 26:
                    case 24:
                        {
                            unknownDims_.AddEntriesFrom(ref input, _repeated_unknownDims_codec);
                            break;
                        }
                    case 32:
                        {
                            UnknownShape = input.ReadBool();
                            break;
                        }
                    case 42:
                        {
                            Name = input.ReadString();
                            break;
                        }
                }
            }
        }
#endif

    }

    public sealed partial class TensorShapes : pb::IMessage<TensorShapes>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TensorShapes> _parser = new pb::MessageParser<TensorShapes>(() => new TensorShapes());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorShapes> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShapes()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShapes(TensorShapes other) : this()
        {
            shapes_ = other.shapes_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShapes Clone()
        {
            return new TensorShapes(this);
        }

        /// <summary>Field number for the "shapes" field.</summary>
        public const int ShapesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Caffe2.TensorShape> _repeated_shapes_codec
            = pb::FieldCodec.ForMessage(10, global::Caffe2.TensorShape.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.TensorShape> shapes_ = new pbc::RepeatedField<global::Caffe2.TensorShape>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.TensorShape> Shapes
        {
            get { return shapes_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TensorShapes);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorShapes other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!shapes_.Equals(other.shapes_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= shapes_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      shapes_.WriteTo(output, _repeated_shapes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            shapes_.WriteTo(ref output, _repeated_shapes_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += shapes_.CalculateSize(_repeated_shapes_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorShapes other)
        {
            if (other == null)
            {
                return;
            }
            shapes_.Add(other.shapes_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            shapes_.AddEntriesFrom(input, _repeated_shapes_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            shapes_.AddEntriesFrom(ref input, _repeated_shapes_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// TensorBoundShape is used to save bound shape inference result for a tensor.
    /// TensorBoundShape.shape is inferred shape for this tensor.
    /// TensorBoundShape.dimType contains dim_type for every dimension.
    /// eg: for dimension i, shape.dims[i] is the inferred shape and
    /// dim_type[i] is corresponding dim_type.
    /// </summary>
    public sealed partial class TensorBoundShape : pb::IMessage<TensorBoundShape>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TensorBoundShape> _parser = new pb::MessageParser<TensorBoundShape>(() => new TensorBoundShape());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorBoundShape> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorBoundShape()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorBoundShape(TensorBoundShape other) : this()
        {
            _hasBits0 = other._hasBits0;
            shape_ = other.shape_ != null ? other.shape_.Clone() : null;
            dimType_ = other.dimType_.Clone();
            name_ = other.name_;
            shapeIsFinal_ = other.shapeIsFinal_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorBoundShape Clone()
        {
            return new TensorBoundShape(this);
        }

        /// <summary>Field number for the "shape" field.</summary>
        public const int ShapeFieldNumber = 1;
        private global::Caffe2.TensorShape shape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorShape Shape
        {
            get { return shape_; }
            set
            {
                shape_ = value;
            }
        }

        /// <summary>Field number for the "dim_type" field.</summary>
        public const int DimTypeFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Caffe2.TensorBoundShape.Types.DimType> _repeated_dimType_codec
            = pb::FieldCodec.ForEnum(16, x => (int)x, x => (global::Caffe2.TensorBoundShape.Types.DimType)x);
        private readonly pbc::RepeatedField<global::Caffe2.TensorBoundShape.Types.DimType> dimType_ = new pbc::RepeatedField<global::Caffe2.TensorBoundShape.Types.DimType>();
        /// <summary>
        /// dim_type.size() == shape.dims.size()
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.TensorBoundShape.Types.DimType> DimType
        {
            get { return dimType_; }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 3;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "shape_is_final" field.</summary>
        public const int ShapeIsFinalFieldNumber = 4;
        private readonly static bool ShapeIsFinalDefaultValue = false;

        private bool shapeIsFinal_;
        /// <summary>
        /// a flag to indicate whether the shape is final and cannot be changed
        /// eg: input/output of in-place ops
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ShapeIsFinal
        {
            get { if ((_hasBits0 & 1) != 0) { return shapeIsFinal_; } else { return ShapeIsFinalDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                shapeIsFinal_ = value;
            }
        }
        /// <summary>Gets whether the "shape_is_final" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasShapeIsFinal
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "shape_is_final" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearShapeIsFinal()
        {
            _hasBits0 &= ~1;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TensorBoundShape);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorBoundShape other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Shape, other.Shape)) return false;
            if (!dimType_.Equals(other.dimType_)) return false;
            if (Name != other.Name) return false;
            if (ShapeIsFinal != other.ShapeIsFinal) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (shape_ != null) hash ^= Shape.GetHashCode();
            hash ^= dimType_.GetHashCode();
            if (HasName) hash ^= Name.GetHashCode();
            if (HasShapeIsFinal) hash ^= ShapeIsFinal.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (shape_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Shape);
      }
      dimType_.WriteTo(output, _repeated_dimType_codec);
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (HasShapeIsFinal) {
        output.WriteRawTag(32);
        output.WriteBool(ShapeIsFinal);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (shape_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Shape);
            }
            dimType_.WriteTo(ref output, _repeated_dimType_codec);
            if (HasName)
            {
                output.WriteRawTag(26);
                output.WriteString(Name);
            }
            if (HasShapeIsFinal)
            {
                output.WriteRawTag(32);
                output.WriteBool(ShapeIsFinal);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (shape_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
            }
            size += dimType_.CalculateSize(_repeated_dimType_codec);
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (HasShapeIsFinal)
            {
                size += 1 + 1;
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorBoundShape other)
        {
            if (other == null)
            {
                return;
            }
            if (other.shape_ != null)
            {
                if (shape_ == null)
                {
                    Shape = new global::Caffe2.TensorShape();
                }
                Shape.MergeFrom(other.Shape);
            }
            dimType_.Add(other.dimType_);
            if (other.HasName)
            {
                Name = other.Name;
            }
            if (other.HasShapeIsFinal)
            {
                ShapeIsFinal = other.ShapeIsFinal;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (shape_ == null) {
              Shape = new global::Caffe2.TensorShape();
            }
            input.ReadMessage(Shape);
            break;
          }
          case 18:
          case 16: {
            dimType_.AddEntriesFrom(input, _repeated_dimType_codec);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 32: {
            ShapeIsFinal = input.ReadBool();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            if (shape_ == null)
                            {
                                Shape = new global::Caffe2.TensorShape();
                            }
                            input.ReadMessage(Shape);
                            break;
                        }
                    case 18:
                    case 16:
                        {
                            dimType_.AddEntriesFrom(ref input, _repeated_dimType_codec);
                            break;
                        }
                    case 26:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 32:
                        {
                            ShapeIsFinal = input.ReadBool();
                            break;
                        }
                }
            }
        }
#endif

        #region Nested types
        /// <summary>Container for nested types declared in the TensorBoundShape message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            public enum DimType
            {
                /// <summary>
                /// unknown
                /// </summary>
                [pbr::OriginalName("UNKNOWN")] Unknown = 0,
                /// <summary>
                /// constant
                /// </summary>
                [pbr::OriginalName("CONSTANT")] Constant = 1,
                /// <summary>
                /// batch, corresponding dimension is batch_size
                /// </summary>
                [pbr::OriginalName("BATCH")] Batch = 2,
                /// <summary>
                /// batch_of_feature_max,
                /// corresponding shape is inferred_feature_length * batch_size
                /// </summary>
                [pbr::OriginalName("BATCH_OF_FEATURE_MAX")] BatchOfFeatureMax = 3,
                /// <summary>
                /// batch_of_feature_max_default
                /// corresponding shape is default_feature_length * batch_size
                /// </summary>
                [pbr::OriginalName("BATCH_OF_FEATURE_MAX_DEFAULT")] BatchOfFeatureMaxDefault = 4,
                /// <summary>
                /// feature_max, corresponding shape is inferred_feature_length
                /// </summary>
                [pbr::OriginalName("FEATURE_MAX")] FeatureMax = 5,
                /// <summary>
                /// feature_max_default, corresponding shape is default_feature_length
                /// </summary>
                [pbr::OriginalName("FEATURE_MAX_DEFAULT")] FeatureMaxDefault = 6,
            }

        }
        #endregion

    }

    public sealed partial class TensorBoundShapes : pb::IMessage<TensorBoundShapes>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TensorBoundShapes> _parser = new pb::MessageParser<TensorBoundShapes>(() => new TensorBoundShapes());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorBoundShapes> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorBoundShapes()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorBoundShapes(TensorBoundShapes other) : this()
        {
            _hasBits0 = other._hasBits0;
            shapes_ = other.shapes_.Clone();
            maxBatchSize_ = other.maxBatchSize_;
            maxFeatureLen_ = other.maxFeatureLen_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorBoundShapes Clone()
        {
            return new TensorBoundShapes(this);
        }

        /// <summary>Field number for the "shapes" field.</summary>
        public const int ShapesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Caffe2.TensorBoundShape> _repeated_shapes_codec
            = pb::FieldCodec.ForMessage(10, global::Caffe2.TensorBoundShape.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.TensorBoundShape> shapes_ = new pbc::RepeatedField<global::Caffe2.TensorBoundShape>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.TensorBoundShape> Shapes
        {
            get { return shapes_; }
        }

        /// <summary>Field number for the "max_batch_size" field.</summary>
        public const int MaxBatchSizeFieldNumber = 2;
        private readonly static long MaxBatchSizeDefaultValue = 0L;

        private long maxBatchSize_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long MaxBatchSize
        {
            get { if ((_hasBits0 & 1) != 0) { return maxBatchSize_; } else { return MaxBatchSizeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                maxBatchSize_ = value;
            }
        }
        /// <summary>Gets whether the "max_batch_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMaxBatchSize
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "max_batch_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMaxBatchSize()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "max_feature_len" field.</summary>
        public const int MaxFeatureLenFieldNumber = 3;
        private readonly static long MaxFeatureLenDefaultValue = 0L;

        private long maxFeatureLen_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long MaxFeatureLen
        {
            get { if ((_hasBits0 & 2) != 0) { return maxFeatureLen_; } else { return MaxFeatureLenDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                maxFeatureLen_ = value;
            }
        }
        /// <summary>Gets whether the "max_feature_len" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMaxFeatureLen
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "max_feature_len" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMaxFeatureLen()
        {
            _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TensorBoundShapes);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorBoundShapes other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!shapes_.Equals(other.shapes_)) return false;
            if (MaxBatchSize != other.MaxBatchSize) return false;
            if (MaxFeatureLen != other.MaxFeatureLen) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= shapes_.GetHashCode();
            if (HasMaxBatchSize) hash ^= MaxBatchSize.GetHashCode();
            if (HasMaxFeatureLen) hash ^= MaxFeatureLen.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      shapes_.WriteTo(output, _repeated_shapes_codec);
      if (HasMaxBatchSize) {
        output.WriteRawTag(16);
        output.WriteInt64(MaxBatchSize);
      }
      if (HasMaxFeatureLen) {
        output.WriteRawTag(24);
        output.WriteInt64(MaxFeatureLen);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            shapes_.WriteTo(ref output, _repeated_shapes_codec);
            if (HasMaxBatchSize)
            {
                output.WriteRawTag(16);
                output.WriteInt64(MaxBatchSize);
            }
            if (HasMaxFeatureLen)
            {
                output.WriteRawTag(24);
                output.WriteInt64(MaxFeatureLen);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += shapes_.CalculateSize(_repeated_shapes_codec);
            if (HasMaxBatchSize)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxBatchSize);
            }
            if (HasMaxFeatureLen)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxFeatureLen);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorBoundShapes other)
        {
            if (other == null)
            {
                return;
            }
            shapes_.Add(other.shapes_);
            if (other.HasMaxBatchSize)
            {
                MaxBatchSize = other.MaxBatchSize;
            }
            if (other.HasMaxFeatureLen)
            {
                MaxFeatureLen = other.MaxFeatureLen;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            shapes_.AddEntriesFrom(input, _repeated_shapes_codec);
            break;
          }
          case 16: {
            MaxBatchSize = input.ReadInt64();
            break;
          }
          case 24: {
            MaxFeatureLen = input.ReadInt64();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            shapes_.AddEntriesFrom(ref input, _repeated_shapes_codec);
                            break;
                        }
                    case 16:
                        {
                            MaxBatchSize = input.ReadInt64();
                            break;
                        }
                    case 24:
                        {
                            MaxFeatureLen = input.ReadInt64();
                            break;
                        }
                }
            }
        }
#endif

    }

    public sealed partial class AOTConfig : pb::IMessage<AOTConfig>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<AOTConfig> _parser = new pb::MessageParser<AOTConfig>(() => new AOTConfig());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AOTConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AOTConfig()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AOTConfig(AOTConfig other) : this()
        {
            _hasBits0 = other._hasBits0;
            maxBatchSize_ = other.maxBatchSize_;
            maxSeqSize_ = other.maxSeqSize_;
            inBatchBroadcast_ = other.inBatchBroadcast_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AOTConfig Clone()
        {
            return new AOTConfig(this);
        }

        /// <summary>Field number for the "max_batch_size" field.</summary>
        public const int MaxBatchSizeFieldNumber = 1;
        private readonly static long MaxBatchSizeDefaultValue = 0L;

        private long maxBatchSize_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long MaxBatchSize
        {
            get { if ((_hasBits0 & 1) != 0) { return maxBatchSize_; } else { return MaxBatchSizeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                maxBatchSize_ = value;
            }
        }
        /// <summary>Gets whether the "max_batch_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMaxBatchSize
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "max_batch_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMaxBatchSize()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "max_seq_size" field.</summary>
        public const int MaxSeqSizeFieldNumber = 2;
        private readonly static long MaxSeqSizeDefaultValue = 0L;

        private long maxSeqSize_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long MaxSeqSize
        {
            get { if ((_hasBits0 & 2) != 0) { return maxSeqSize_; } else { return MaxSeqSizeDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                maxSeqSize_ = value;
            }
        }
        /// <summary>Gets whether the "max_seq_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMaxSeqSize
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "max_seq_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMaxSeqSize()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "in_batch_broadcast" field.</summary>
        public const int InBatchBroadcastFieldNumber = 3;
        private readonly static bool InBatchBroadcastDefaultValue = false;

        private bool inBatchBroadcast_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool InBatchBroadcast
        {
            get { if ((_hasBits0 & 4) != 0) { return inBatchBroadcast_; } else { return InBatchBroadcastDefaultValue; } }
            set
            {
                _hasBits0 |= 4;
                inBatchBroadcast_ = value;
            }
        }
        /// <summary>Gets whether the "in_batch_broadcast" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasInBatchBroadcast
        {
            get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "in_batch_broadcast" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearInBatchBroadcast()
        {
            _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as AOTConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AOTConfig other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (MaxBatchSize != other.MaxBatchSize) return false;
            if (MaxSeqSize != other.MaxSeqSize) return false;
            if (InBatchBroadcast != other.InBatchBroadcast) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasMaxBatchSize) hash ^= MaxBatchSize.GetHashCode();
            if (HasMaxSeqSize) hash ^= MaxSeqSize.GetHashCode();
            if (HasInBatchBroadcast) hash ^= InBatchBroadcast.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasMaxBatchSize) {
        output.WriteRawTag(8);
        output.WriteInt64(MaxBatchSize);
      }
      if (HasMaxSeqSize) {
        output.WriteRawTag(16);
        output.WriteInt64(MaxSeqSize);
      }
      if (HasInBatchBroadcast) {
        output.WriteRawTag(24);
        output.WriteBool(InBatchBroadcast);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasMaxBatchSize)
            {
                output.WriteRawTag(8);
                output.WriteInt64(MaxBatchSize);
            }
            if (HasMaxSeqSize)
            {
                output.WriteRawTag(16);
                output.WriteInt64(MaxSeqSize);
            }
            if (HasInBatchBroadcast)
            {
                output.WriteRawTag(24);
                output.WriteBool(InBatchBroadcast);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasMaxBatchSize)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxBatchSize);
            }
            if (HasMaxSeqSize)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxSeqSize);
            }
            if (HasInBatchBroadcast)
            {
                size += 1 + 1;
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AOTConfig other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasMaxBatchSize)
            {
                MaxBatchSize = other.MaxBatchSize;
            }
            if (other.HasMaxSeqSize)
            {
                MaxSeqSize = other.MaxSeqSize;
            }
            if (other.HasInBatchBroadcast)
            {
                InBatchBroadcast = other.InBatchBroadcast;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxBatchSize = input.ReadInt64();
            break;
          }
          case 16: {
            MaxSeqSize = input.ReadInt64();
            break;
          }
          case 24: {
            InBatchBroadcast = input.ReadBool();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 8:
                        {
                            MaxBatchSize = input.ReadInt64();
                            break;
                        }
                    case 16:
                        {
                            MaxSeqSize = input.ReadInt64();
                            break;
                        }
                    case 24:
                        {
                            InBatchBroadcast = input.ReadBool();
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// A named argument containing either singular float, integer and string
    /// values, or repeated float, int and string arrays.
    /// </summary>
    public sealed partial class Argument : pb::IMessage<Argument>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<Argument> _parser = new pb::MessageParser<Argument>(() => new Argument());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Argument> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[9]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Argument()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Argument(Argument other) : this()
        {
            _hasBits0 = other._hasBits0;
            name_ = other.name_;
            f_ = other.f_;
            i_ = other.i_;
            s_ = other.s_;
            t_ = other.t_ != null ? other.t_.Clone() : null;
            n_ = other.n_ != null ? other.n_.Clone() : null;
            floats_ = other.floats_.Clone();
            ints_ = other.ints_.Clone();
            strings_ = other.strings_.Clone();
            tensors_ = other.tensors_.Clone();
            nets_ = other.nets_.Clone();
            qtensors_ = other.qtensors_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Argument Clone()
        {
            return new Argument(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "f" field.</summary>
        public const int FFieldNumber = 2;
        private readonly static float FDefaultValue = 0F;

        private float f_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float F
        {
            get { if ((_hasBits0 & 1) != 0) { return f_; } else { return FDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                f_ = value;
            }
        }
        /// <summary>Gets whether the "f" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasF
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "f" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearF()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "i" field.</summary>
        public const int IFieldNumber = 3;
        private readonly static long IDefaultValue = 0L;

        private long i_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long I
        {
            get { if ((_hasBits0 & 2) != 0) { return i_; } else { return IDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                i_ = value;
            }
        }
        /// <summary>Gets whether the "i" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasI
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "i" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearI()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "s" field.</summary>
        public const int SFieldNumber = 4;
        private readonly static pb::ByteString SDefaultValue = pb::ByteString.Empty;

        private pb::ByteString s_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString S
        {
            get { return s_ ?? SDefaultValue; }
            set
            {
                s_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "s" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasS
        {
            get { return s_ != null; }
        }
        /// <summary>Clears the value of the "s" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearS()
        {
            s_ = null;
        }

        /// <summary>Field number for the "t" field.</summary>
        public const int TFieldNumber = 10;
        private global::Caffe2.TensorProto t_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorProto T
        {
            get { return t_; }
            set
            {
                t_ = value;
            }
        }

        /// <summary>Field number for the "n" field.</summary>
        public const int NFieldNumber = 8;
        private global::Caffe2.NetDef n_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.NetDef N
        {
            get { return n_; }
            set
            {
                n_ = value;
            }
        }

        /// <summary>Field number for the "floats" field.</summary>
        public const int FloatsFieldNumber = 5;
        private static readonly pb::FieldCodec<float> _repeated_floats_codec
            = pb::FieldCodec.ForFloat(45);
        private readonly pbc::RepeatedField<float> floats_ = new pbc::RepeatedField<float>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<float> Floats
        {
            get { return floats_; }
        }

        /// <summary>Field number for the "ints" field.</summary>
        public const int IntsFieldNumber = 6;
        private static readonly pb::FieldCodec<long> _repeated_ints_codec
            = pb::FieldCodec.ForInt64(48);
        private readonly pbc::RepeatedField<long> ints_ = new pbc::RepeatedField<long>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Ints
        {
            get { return ints_; }
        }

        /// <summary>Field number for the "strings" field.</summary>
        public const int StringsFieldNumber = 7;
        private static readonly pb::FieldCodec<pb::ByteString> _repeated_strings_codec
            = pb::FieldCodec.ForBytes(58);
        private readonly pbc::RepeatedField<pb::ByteString> strings_ = new pbc::RepeatedField<pb::ByteString>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<pb::ByteString> Strings
        {
            get { return strings_; }
        }

        /// <summary>Field number for the "tensors" field.</summary>
        public const int TensorsFieldNumber = 11;
        private static readonly pb::FieldCodec<global::Caffe2.TensorProto> _repeated_tensors_codec
            = pb::FieldCodec.ForMessage(90, global::Caffe2.TensorProto.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.TensorProto> tensors_ = new pbc::RepeatedField<global::Caffe2.TensorProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.TensorProto> Tensors
        {
            get { return tensors_; }
        }

        /// <summary>Field number for the "nets" field.</summary>
        public const int NetsFieldNumber = 9;
        private static readonly pb::FieldCodec<global::Caffe2.NetDef> _repeated_nets_codec
            = pb::FieldCodec.ForMessage(74, global::Caffe2.NetDef.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.NetDef> nets_ = new pbc::RepeatedField<global::Caffe2.NetDef>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.NetDef> Nets
        {
            get { return nets_; }
        }

        /// <summary>Field number for the "qtensors" field.</summary>
        public const int QtensorsFieldNumber = 12;
        private static readonly pb::FieldCodec<global::Caffe2.QTensorProto> _repeated_qtensors_codec
            = pb::FieldCodec.ForMessage(98, global::Caffe2.QTensorProto.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.QTensorProto> qtensors_ = new pbc::RepeatedField<global::Caffe2.QTensorProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.QTensorProto> Qtensors
        {
            get { return qtensors_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Argument);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Argument other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(F, other.F)) return false;
            if (I != other.I) return false;
            if (S != other.S) return false;
            if (!object.Equals(T, other.T)) return false;
            if (!object.Equals(N, other.N)) return false;
            if (!floats_.Equals(other.floats_)) return false;
            if (!ints_.Equals(other.ints_)) return false;
            if (!strings_.Equals(other.strings_)) return false;
            if (!tensors_.Equals(other.tensors_)) return false;
            if (!nets_.Equals(other.nets_)) return false;
            if (!qtensors_.Equals(other.qtensors_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasName) hash ^= Name.GetHashCode();
            if (HasF) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(F);
            if (HasI) hash ^= I.GetHashCode();
            if (HasS) hash ^= S.GetHashCode();
            if (t_ != null) hash ^= T.GetHashCode();
            if (n_ != null) hash ^= N.GetHashCode();
            hash ^= floats_.GetHashCode();
            hash ^= ints_.GetHashCode();
            hash ^= strings_.GetHashCode();
            hash ^= tensors_.GetHashCode();
            hash ^= nets_.GetHashCode();
            hash ^= qtensors_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasF) {
        output.WriteRawTag(21);
        output.WriteFloat(F);
      }
      if (HasI) {
        output.WriteRawTag(24);
        output.WriteInt64(I);
      }
      if (HasS) {
        output.WriteRawTag(34);
        output.WriteBytes(S);
      }
      floats_.WriteTo(output, _repeated_floats_codec);
      ints_.WriteTo(output, _repeated_ints_codec);
      strings_.WriteTo(output, _repeated_strings_codec);
      if (n_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(N);
      }
      nets_.WriteTo(output, _repeated_nets_codec);
      if (t_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(T);
      }
      tensors_.WriteTo(output, _repeated_tensors_codec);
      qtensors_.WriteTo(output, _repeated_qtensors_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasName)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (HasF)
            {
                output.WriteRawTag(21);
                output.WriteFloat(F);
            }
            if (HasI)
            {
                output.WriteRawTag(24);
                output.WriteInt64(I);
            }
            if (HasS)
            {
                output.WriteRawTag(34);
                output.WriteBytes(S);
            }
            floats_.WriteTo(ref output, _repeated_floats_codec);
            ints_.WriteTo(ref output, _repeated_ints_codec);
            strings_.WriteTo(ref output, _repeated_strings_codec);
            if (n_ != null)
            {
                output.WriteRawTag(66);
                output.WriteMessage(N);
            }
            nets_.WriteTo(ref output, _repeated_nets_codec);
            if (t_ != null)
            {
                output.WriteRawTag(82);
                output.WriteMessage(T);
            }
            tensors_.WriteTo(ref output, _repeated_tensors_codec);
            qtensors_.WriteTo(ref output, _repeated_qtensors_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (HasF)
            {
                size += 1 + 4;
            }
            if (HasI)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(I);
            }
            if (HasS)
            {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(S);
            }
            if (t_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(T);
            }
            if (n_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(N);
            }
            size += floats_.CalculateSize(_repeated_floats_codec);
            size += ints_.CalculateSize(_repeated_ints_codec);
            size += strings_.CalculateSize(_repeated_strings_codec);
            size += tensors_.CalculateSize(_repeated_tensors_codec);
            size += nets_.CalculateSize(_repeated_nets_codec);
            size += qtensors_.CalculateSize(_repeated_qtensors_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Argument other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            if (other.HasF)
            {
                F = other.F;
            }
            if (other.HasI)
            {
                I = other.I;
            }
            if (other.HasS)
            {
                S = other.S;
            }
            if (other.t_ != null)
            {
                if (t_ == null)
                {
                    T = new global::Caffe2.TensorProto();
                }
                T.MergeFrom(other.T);
            }
            if (other.n_ != null)
            {
                if (n_ == null)
                {
                    N = new global::Caffe2.NetDef();
                }
                N.MergeFrom(other.N);
            }
            floats_.Add(other.floats_);
            ints_.Add(other.ints_);
            strings_.Add(other.strings_);
            tensors_.Add(other.tensors_);
            nets_.Add(other.nets_);
            qtensors_.Add(other.qtensors_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 21: {
            F = input.ReadFloat();
            break;
          }
          case 24: {
            I = input.ReadInt64();
            break;
          }
          case 34: {
            S = input.ReadBytes();
            break;
          }
          case 42:
          case 45: {
            floats_.AddEntriesFrom(input, _repeated_floats_codec);
            break;
          }
          case 50:
          case 48: {
            ints_.AddEntriesFrom(input, _repeated_ints_codec);
            break;
          }
          case 58: {
            strings_.AddEntriesFrom(input, _repeated_strings_codec);
            break;
          }
          case 66: {
            if (n_ == null) {
              N = new global::Caffe2.NetDef();
            }
            input.ReadMessage(N);
            break;
          }
          case 74: {
            nets_.AddEntriesFrom(input, _repeated_nets_codec);
            break;
          }
          case 82: {
            if (t_ == null) {
              T = new global::Caffe2.TensorProto();
            }
            input.ReadMessage(T);
            break;
          }
          case 90: {
            tensors_.AddEntriesFrom(input, _repeated_tensors_codec);
            break;
          }
          case 98: {
            qtensors_.AddEntriesFrom(input, _repeated_qtensors_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 21:
                        {
                            F = input.ReadFloat();
                            break;
                        }
                    case 24:
                        {
                            I = input.ReadInt64();
                            break;
                        }
                    case 34:
                        {
                            S = input.ReadBytes();
                            break;
                        }
                    case 42:
                    case 45:
                        {
                            floats_.AddEntriesFrom(ref input, _repeated_floats_codec);
                            break;
                        }
                    case 50:
                    case 48:
                        {
                            ints_.AddEntriesFrom(ref input, _repeated_ints_codec);
                            break;
                        }
                    case 58:
                        {
                            strings_.AddEntriesFrom(ref input, _repeated_strings_codec);
                            break;
                        }
                    case 66:
                        {
                            if (n_ == null)
                            {
                                N = new global::Caffe2.NetDef();
                            }
                            input.ReadMessage(N);
                            break;
                        }
                    case 74:
                        {
                            nets_.AddEntriesFrom(ref input, _repeated_nets_codec);
                            break;
                        }
                    case 82:
                        {
                            if (t_ == null)
                            {
                                T = new global::Caffe2.TensorProto();
                            }
                            input.ReadMessage(T);
                            break;
                        }
                    case 90:
                        {
                            tensors_.AddEntriesFrom(ref input, _repeated_tensors_codec);
                            break;
                        }
                    case 98:
                        {
                            qtensors_.AddEntriesFrom(ref input, _repeated_qtensors_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// Device-specific options. We do not distinguish DeviceOption protos for
    /// different DeviceTypes, so currently all devices share the same DeviceOption
    /// proto. Fields that are specific to a device type is ignored if the type does
    /// not match.
    /// Note: if you add fields to the DeviceOption, make sure you add the
    /// corresponding changes to IsSameDevice() function in utils/proto_utils.{h,cc}.
    /// </summary>
    public sealed partial class DeviceOption : pb::IMessage<DeviceOption>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<DeviceOption> _parser = new pb::MessageParser<DeviceOption>(() => new DeviceOption());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeviceOption> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[10]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeviceOption()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeviceOption(DeviceOption other) : this()
        {
            _hasBits0 = other._hasBits0;
            deviceType_ = other.deviceType_;
            deviceId_ = other.deviceId_;
            randomSeed_ = other.randomSeed_;
            nodeName_ = other.nodeName_;
            numaNodeId_ = other.numaNodeId_;
            extraInfo_ = other.extraInfo_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeviceOption Clone()
        {
            return new DeviceOption(this);
        }

        /// <summary>Field number for the "device_type" field.</summary>
        public const int DeviceTypeFieldNumber = 1;
        private readonly static int DeviceTypeDefaultValue = 0;

        private int deviceType_;
        /// <summary>
        /// [general] Options that need to be carried out before running the execution.
        /// optional DeviceType device_type = 1 [ default = CPU ];
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int DeviceType
        {
            get { if ((_hasBits0 & 1) != 0) { return deviceType_; } else { return DeviceTypeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                deviceType_ = value;
            }
        }
        /// <summary>Gets whether the "device_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDeviceType
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "device_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDeviceType()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "device_id" field.</summary>
        public const int DeviceIdFieldNumber = 2;
        private readonly static int DeviceIdDefaultValue = 0;

        private int deviceId_;
        /// <summary>
        /// [general] Used together with device_type to identify the exact device
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int DeviceId
        {
            get { if ((_hasBits0 & 2) != 0) { return deviceId_; } else { return DeviceIdDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                deviceId_ = value;
            }
        }
        /// <summary>Gets whether the "device_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDeviceId
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "device_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDeviceId()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "random_seed" field.</summary>
        public const int RandomSeedFieldNumber = 3;
        private readonly static uint RandomSeedDefaultValue = 0;

        private uint randomSeed_;
        /// <summary>
        /// [general] The random seed to start the device random number generator with.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint RandomSeed
        {
            get { if ((_hasBits0 & 4) != 0) { return randomSeed_; } else { return RandomSeedDefaultValue; } }
            set
            {
                _hasBits0 |= 4;
                randomSeed_ = value;
            }
        }
        /// <summary>Gets whether the "random_seed" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasRandomSeed
        {
            get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "random_seed" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearRandomSeed()
        {
            _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "node_name" field.</summary>
        public const int NodeNameFieldNumber = 4;
        private readonly static string NodeNameDefaultValue = "";

        private string nodeName_;
        /// <summary>
        /// [general] What node this op should execute on.
        /// Used for net transformation purposes. Must be empty at execution time.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string NodeName
        {
            get { return nodeName_ ?? NodeNameDefaultValue; }
            set
            {
                nodeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "node_name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasNodeName
        {
            get { return nodeName_ != null; }
        }
        /// <summary>Clears the value of the "node_name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearNodeName()
        {
            nodeName_ = null;
        }

        /// <summary>Field number for the "numa_node_id" field.</summary>
        public const int NumaNodeIdFieldNumber = 5;
        private readonly static int NumaNodeIdDefaultValue = 0;

        private int numaNodeId_;
        /// <summary>
        /// [CPU and Linux specific] NUMA node id
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int NumaNodeId
        {
            get { if ((_hasBits0 & 8) != 0) { return numaNodeId_; } else { return NumaNodeIdDefaultValue; } }
            set
            {
                _hasBits0 |= 8;
                numaNodeId_ = value;
            }
        }
        /// <summary>Gets whether the "numa_node_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasNumaNodeId
        {
            get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "numa_node_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearNumaNodeId()
        {
            _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "extra_info" field.</summary>
        public const int ExtraInfoFieldNumber = 6;
        private static readonly pb::FieldCodec<string> _repeated_extraInfo_codec
            = pb::FieldCodec.ForString(50);
        private readonly pbc::RepeatedField<string> extraInfo_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// [general] Extra information passed, not used at execution time currently.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> ExtraInfo
        {
            get { return extraInfo_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as DeviceOption);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeviceOption other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (DeviceType != other.DeviceType) return false;
            if (DeviceId != other.DeviceId) return false;
            if (RandomSeed != other.RandomSeed) return false;
            if (NodeName != other.NodeName) return false;
            if (NumaNodeId != other.NumaNodeId) return false;
            if (!extraInfo_.Equals(other.extraInfo_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasDeviceType) hash ^= DeviceType.GetHashCode();
            if (HasDeviceId) hash ^= DeviceId.GetHashCode();
            if (HasRandomSeed) hash ^= RandomSeed.GetHashCode();
            if (HasNodeName) hash ^= NodeName.GetHashCode();
            if (HasNumaNodeId) hash ^= NumaNodeId.GetHashCode();
            hash ^= extraInfo_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasDeviceType) {
        output.WriteRawTag(8);
        output.WriteInt32(DeviceType);
      }
      if (HasDeviceId) {
        output.WriteRawTag(16);
        output.WriteInt32(DeviceId);
      }
      if (HasRandomSeed) {
        output.WriteRawTag(24);
        output.WriteUInt32(RandomSeed);
      }
      if (HasNodeName) {
        output.WriteRawTag(34);
        output.WriteString(NodeName);
      }
      if (HasNumaNodeId) {
        output.WriteRawTag(40);
        output.WriteInt32(NumaNodeId);
      }
      extraInfo_.WriteTo(output, _repeated_extraInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasDeviceType)
            {
                output.WriteRawTag(8);
                output.WriteInt32(DeviceType);
            }
            if (HasDeviceId)
            {
                output.WriteRawTag(16);
                output.WriteInt32(DeviceId);
            }
            if (HasRandomSeed)
            {
                output.WriteRawTag(24);
                output.WriteUInt32(RandomSeed);
            }
            if (HasNodeName)
            {
                output.WriteRawTag(34);
                output.WriteString(NodeName);
            }
            if (HasNumaNodeId)
            {
                output.WriteRawTag(40);
                output.WriteInt32(NumaNodeId);
            }
            extraInfo_.WriteTo(ref output, _repeated_extraInfo_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasDeviceType)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(DeviceType);
            }
            if (HasDeviceId)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(DeviceId);
            }
            if (HasRandomSeed)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RandomSeed);
            }
            if (HasNodeName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(NodeName);
            }
            if (HasNumaNodeId)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumaNodeId);
            }
            size += extraInfo_.CalculateSize(_repeated_extraInfo_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeviceOption other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasDeviceType)
            {
                DeviceType = other.DeviceType;
            }
            if (other.HasDeviceId)
            {
                DeviceId = other.DeviceId;
            }
            if (other.HasRandomSeed)
            {
                RandomSeed = other.RandomSeed;
            }
            if (other.HasNodeName)
            {
                NodeName = other.NodeName;
            }
            if (other.HasNumaNodeId)
            {
                NumaNodeId = other.NumaNodeId;
            }
            extraInfo_.Add(other.extraInfo_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DeviceType = input.ReadInt32();
            break;
          }
          case 16: {
            DeviceId = input.ReadInt32();
            break;
          }
          case 24: {
            RandomSeed = input.ReadUInt32();
            break;
          }
          case 34: {
            NodeName = input.ReadString();
            break;
          }
          case 40: {
            NumaNodeId = input.ReadInt32();
            break;
          }
          case 50: {
            extraInfo_.AddEntriesFrom(input, _repeated_extraInfo_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 8:
                        {
                            DeviceType = input.ReadInt32();
                            break;
                        }
                    case 16:
                        {
                            DeviceId = input.ReadInt32();
                            break;
                        }
                    case 24:
                        {
                            RandomSeed = input.ReadUInt32();
                            break;
                        }
                    case 34:
                        {
                            NodeName = input.ReadString();
                            break;
                        }
                    case 40:
                        {
                            NumaNodeId = input.ReadInt32();
                            break;
                        }
                    case 50:
                        {
                            extraInfo_.AddEntriesFrom(ref input, _repeated_extraInfo_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// Operator Definition.
    /// </summary>
    public sealed partial class OperatorDef : pb::IMessage<OperatorDef>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<OperatorDef> _parser = new pb::MessageParser<OperatorDef>(() => new OperatorDef());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<OperatorDef> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[11]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public OperatorDef()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public OperatorDef(OperatorDef other) : this()
        {
            _hasBits0 = other._hasBits0;
            input_ = other.input_.Clone();
            output_ = other.output_.Clone();
            name_ = other.name_;
            type_ = other.type_;
            arg_ = other.arg_.Clone();
            deviceOption_ = other.deviceOption_ != null ? other.deviceOption_.Clone() : null;
            engine_ = other.engine_;
            controlInput_ = other.controlInput_.Clone();
            isGradientOp_ = other.isGradientOp_;
            debugInfo_ = other.debugInfo_;
            domain_ = other.domain_;
            opVersion_ = other.opVersion_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public OperatorDef Clone()
        {
            return new OperatorDef(this);
        }

        /// <summary>Field number for the "input" field.</summary>
        public const int InputFieldNumber = 1;
        private static readonly pb::FieldCodec<string> _repeated_input_codec
            = pb::FieldCodec.ForString(10);
        private readonly pbc::RepeatedField<string> input_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// the name of the input blobs
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Input
        {
            get { return input_; }
        }

        /// <summary>Field number for the "output" field.</summary>
        public const int OutputFieldNumber = 2;
        private static readonly pb::FieldCodec<string> _repeated_output_codec
            = pb::FieldCodec.ForString(18);
        private readonly pbc::RepeatedField<string> output_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// the name of output top blobs
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Output
        {
            get { return output_; }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 3;
        private readonly static string NameDefaultValue = "";

        private string name_;
        /// <summary>
        /// the operator name. This is optional.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 4;
        private readonly static string TypeDefaultValue = "";

        private string type_;
        /// <summary>
        /// the operator type. This is needed to create the object from the operator
        /// registry.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type
        {
            get { return type_ ?? TypeDefaultValue; }
            set
            {
                type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasType
        {
            get { return type_ != null; }
        }
        /// <summary>Clears the value of the "type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearType()
        {
            type_ = null;
        }

        /// <summary>Field number for the "arg" field.</summary>
        public const int ArgFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Caffe2.Argument> _repeated_arg_codec
            = pb::FieldCodec.ForMessage(42, global::Caffe2.Argument.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.Argument> arg_ = new pbc::RepeatedField<global::Caffe2.Argument>();
        /// <summary>
        /// arg is for the argument defined in operator schema
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.Argument> Arg
        {
            get { return arg_; }
        }

        /// <summary>Field number for the "device_option" field.</summary>
        public const int DeviceOptionFieldNumber = 6;
        private global::Caffe2.DeviceOption deviceOption_;
        /// <summary>
        /// The device option that the operator should run under.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.DeviceOption DeviceOption
        {
            get { return deviceOption_; }
            set
            {
                deviceOption_ = value;
            }
        }

        /// <summary>Field number for the "engine" field.</summary>
        public const int EngineFieldNumber = 7;
        private readonly static string EngineDefaultValue = "";

        private string engine_;
        /// <summary>
        /// Optionally, one can specify an engine when there are multiple
        /// implementations available simultaneously for one device type.
        /// If one specifies an engine but that engine does not exist in the compiled
        /// Caffe2 binary, Caffe2 will fall back to the default engine of that device
        /// type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Engine
        {
            get { return engine_ ?? EngineDefaultValue; }
            set
            {
                engine_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "engine" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasEngine
        {
            get { return engine_ != null; }
        }
        /// <summary>Clears the value of the "engine" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearEngine()
        {
            engine_ = null;
        }

        /// <summary>Field number for the "control_input" field.</summary>
        public const int ControlInputFieldNumber = 8;
        private static readonly pb::FieldCodec<string> _repeated_controlInput_codec
            = pb::FieldCodec.ForString(66);
        private readonly pbc::RepeatedField<string> controlInput_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Additional 'fake' inputs used for expressing control dependencies
        /// in the operator graph. This can be used to ensure that an
        /// operator does not run until another operator is ready, for e.g.
        /// scheduling control. These are not passed as actual inputs to the
        /// Operator implementation, and are only used by the Net class for
        /// scheduling purposes.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> ControlInput
        {
            get { return controlInput_; }
        }

        /// <summary>Field number for the "is_gradient_op" field.</summary>
        public const int IsGradientOpFieldNumber = 9;
        private readonly static bool IsGradientOpDefaultValue = false;

        private bool isGradientOp_;
        /// <summary>
        /// is_gradient_op argument is only used as a hint in shape inference
        /// and has no runtime significance
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsGradientOp
        {
            get { if ((_hasBits0 & 1) != 0) { return isGradientOp_; } else { return IsGradientOpDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                isGradientOp_ = value;
            }
        }
        /// <summary>Gets whether the "is_gradient_op" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasIsGradientOp
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "is_gradient_op" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearIsGradientOp()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "debug_info" field.</summary>
        public const int DebugInfoFieldNumber = 10;
        private readonly static string DebugInfoDefaultValue = "";

        private string debugInfo_;
        /// <summary>
        /// debug information associated with the construction of the operator.
        /// This is an optional string with no assumed characteristics as
        /// operators can be constructed in any language.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DebugInfo
        {
            get { return debugInfo_ ?? DebugInfoDefaultValue; }
            set
            {
                debugInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "debug_info" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDebugInfo
        {
            get { return debugInfo_ != null; }
        }
        /// <summary>Clears the value of the "debug_info" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDebugInfo()
        {
            debugInfo_ = null;
        }

        /// <summary>Field number for the "domain" field.</summary>
        public const int DomainFieldNumber = 11;
        private readonly static string DomainDefaultValue = "";

        private string domain_;
        /// <summary>
        /// the domain of the operator to help runtime distinguish which operator
        /// library this OperatorDef refers to. For example, both caffe2 and aten
        /// has `Add` operator, with domain, we can easily decide which operator
        /// to execute. to support multiple operator libs, we use domain to
        /// distinguish which operator lib we refer to:
        ///   - "caffe2" means this uses Caffe2 operator library
        ///   - "aten" means this uses ATen operator library
        ///   - "c10" is for the fused library
        ///   - if the domain is missing or empty, we use "caffe2", this is for
        ///     legacy models, new serializer should always export an OperatorDef
        ///     with domain and op_version
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Domain
        {
            get { return domain_ ?? DomainDefaultValue; }
            set
            {
                domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "domain" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDomain
        {
            get { return domain_ != null; }
        }
        /// <summary>Clears the value of the "domain" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDomain()
        {
            domain_ = null;
        }

        /// <summary>Field number for the "op_version" field.</summary>
        public const int OpVersionFieldNumber = 12;
        private readonly static long OpVersionDefaultValue = 0L;

        private long opVersion_;
        /// <summary>
        /// each operator is has its own version number.
        /// operator version information
        /// each time, we change the API or semantics of the operator,
        /// we bump the version for the operator.
        /// the runtime system should check the op_version of each OperatorDef
        /// and decide it should reject or accept the model
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long OpVersion
        {
            get { if ((_hasBits0 & 2) != 0) { return opVersion_; } else { return OpVersionDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                opVersion_ = value;
            }
        }
        /// <summary>Gets whether the "op_version" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasOpVersion
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "op_version" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearOpVersion()
        {
            _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as OperatorDef);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(OperatorDef other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!input_.Equals(other.input_)) return false;
            if (!output_.Equals(other.output_)) return false;
            if (Name != other.Name) return false;
            if (Type != other.Type) return false;
            if (!arg_.Equals(other.arg_)) return false;
            if (!object.Equals(DeviceOption, other.DeviceOption)) return false;
            if (Engine != other.Engine) return false;
            if (!controlInput_.Equals(other.controlInput_)) return false;
            if (IsGradientOp != other.IsGradientOp) return false;
            if (DebugInfo != other.DebugInfo) return false;
            if (Domain != other.Domain) return false;
            if (OpVersion != other.OpVersion) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= input_.GetHashCode();
            hash ^= output_.GetHashCode();
            if (HasName) hash ^= Name.GetHashCode();
            if (HasType) hash ^= Type.GetHashCode();
            hash ^= arg_.GetHashCode();
            if (deviceOption_ != null) hash ^= DeviceOption.GetHashCode();
            if (HasEngine) hash ^= Engine.GetHashCode();
            hash ^= controlInput_.GetHashCode();
            if (HasIsGradientOp) hash ^= IsGradientOp.GetHashCode();
            if (HasDebugInfo) hash ^= DebugInfo.GetHashCode();
            if (HasDomain) hash ^= Domain.GetHashCode();
            if (HasOpVersion) hash ^= OpVersion.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      arg_.WriteTo(output, _repeated_arg_codec);
      if (deviceOption_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DeviceOption);
      }
      if (HasEngine) {
        output.WriteRawTag(58);
        output.WriteString(Engine);
      }
      controlInput_.WriteTo(output, _repeated_controlInput_codec);
      if (HasIsGradientOp) {
        output.WriteRawTag(72);
        output.WriteBool(IsGradientOp);
      }
      if (HasDebugInfo) {
        output.WriteRawTag(82);
        output.WriteString(DebugInfo);
      }
      if (HasDomain) {
        output.WriteRawTag(90);
        output.WriteString(Domain);
      }
      if (HasOpVersion) {
        output.WriteRawTag(96);
        output.WriteInt64(OpVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            input_.WriteTo(ref output, _repeated_input_codec);
            output_.WriteTo(ref output, _repeated_output_codec);
            if (HasName)
            {
                output.WriteRawTag(26);
                output.WriteString(Name);
            }
            if (HasType)
            {
                output.WriteRawTag(34);
                output.WriteString(Type);
            }
            arg_.WriteTo(ref output, _repeated_arg_codec);
            if (deviceOption_ != null)
            {
                output.WriteRawTag(50);
                output.WriteMessage(DeviceOption);
            }
            if (HasEngine)
            {
                output.WriteRawTag(58);
                output.WriteString(Engine);
            }
            controlInput_.WriteTo(ref output, _repeated_controlInput_codec);
            if (HasIsGradientOp)
            {
                output.WriteRawTag(72);
                output.WriteBool(IsGradientOp);
            }
            if (HasDebugInfo)
            {
                output.WriteRawTag(82);
                output.WriteString(DebugInfo);
            }
            if (HasDomain)
            {
                output.WriteRawTag(90);
                output.WriteString(Domain);
            }
            if (HasOpVersion)
            {
                output.WriteRawTag(96);
                output.WriteInt64(OpVersion);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += input_.CalculateSize(_repeated_input_codec);
            size += output_.CalculateSize(_repeated_output_codec);
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (HasType)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
            }
            size += arg_.CalculateSize(_repeated_arg_codec);
            if (deviceOption_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeviceOption);
            }
            if (HasEngine)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Engine);
            }
            size += controlInput_.CalculateSize(_repeated_controlInput_codec);
            if (HasIsGradientOp)
            {
                size += 1 + 1;
            }
            if (HasDebugInfo)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DebugInfo);
            }
            if (HasDomain)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
            }
            if (HasOpVersion)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(OpVersion);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(OperatorDef other)
        {
            if (other == null)
            {
                return;
            }
            input_.Add(other.input_);
            output_.Add(other.output_);
            if (other.HasName)
            {
                Name = other.Name;
            }
            if (other.HasType)
            {
                Type = other.Type;
            }
            arg_.Add(other.arg_);
            if (other.deviceOption_ != null)
            {
                if (deviceOption_ == null)
                {
                    DeviceOption = new global::Caffe2.DeviceOption();
                }
                DeviceOption.MergeFrom(other.DeviceOption);
            }
            if (other.HasEngine)
            {
                Engine = other.Engine;
            }
            controlInput_.Add(other.controlInput_);
            if (other.HasIsGradientOp)
            {
                IsGradientOp = other.IsGradientOp;
            }
            if (other.HasDebugInfo)
            {
                DebugInfo = other.DebugInfo;
            }
            if (other.HasDomain)
            {
                Domain = other.Domain;
            }
            if (other.HasOpVersion)
            {
                OpVersion = other.OpVersion;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 18: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            arg_.AddEntriesFrom(input, _repeated_arg_codec);
            break;
          }
          case 50: {
            if (deviceOption_ == null) {
              DeviceOption = new global::Caffe2.DeviceOption();
            }
            input.ReadMessage(DeviceOption);
            break;
          }
          case 58: {
            Engine = input.ReadString();
            break;
          }
          case 66: {
            controlInput_.AddEntriesFrom(input, _repeated_controlInput_codec);
            break;
          }
          case 72: {
            IsGradientOp = input.ReadBool();
            break;
          }
          case 82: {
            DebugInfo = input.ReadString();
            break;
          }
          case 90: {
            Domain = input.ReadString();
            break;
          }
          case 96: {
            OpVersion = input.ReadInt64();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            input_.AddEntriesFrom(ref input, _repeated_input_codec);
                            break;
                        }
                    case 18:
                        {
                            output_.AddEntriesFrom(ref input, _repeated_output_codec);
                            break;
                        }
                    case 26:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 34:
                        {
                            Type = input.ReadString();
                            break;
                        }
                    case 42:
                        {
                            arg_.AddEntriesFrom(ref input, _repeated_arg_codec);
                            break;
                        }
                    case 50:
                        {
                            if (deviceOption_ == null)
                            {
                                DeviceOption = new global::Caffe2.DeviceOption();
                            }
                            input.ReadMessage(DeviceOption);
                            break;
                        }
                    case 58:
                        {
                            Engine = input.ReadString();
                            break;
                        }
                    case 66:
                        {
                            controlInput_.AddEntriesFrom(ref input, _repeated_controlInput_codec);
                            break;
                        }
                    case 72:
                        {
                            IsGradientOp = input.ReadBool();
                            break;
                        }
                    case 82:
                        {
                            DebugInfo = input.ReadString();
                            break;
                        }
                    case 90:
                        {
                            Domain = input.ReadString();
                            break;
                        }
                    case 96:
                        {
                            OpVersion = input.ReadInt64();
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// MapFieldEntry follows the pattern for cross-proto-version maps.
    /// See https://developers.google.com/protocol-buffers/docs/proto3#maps
    /// </summary>
    public sealed partial class MapFieldEntry : pb::IMessage<MapFieldEntry>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<MapFieldEntry> _parser = new pb::MessageParser<MapFieldEntry>(() => new MapFieldEntry());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MapFieldEntry> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[12]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapFieldEntry()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapFieldEntry(MapFieldEntry other) : this()
        {
            key_ = other.key_;
            val_ = other.val_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapFieldEntry Clone()
        {
            return new MapFieldEntry(this);
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 1;
        private readonly static string KeyDefaultValue = "";

        private string key_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Key
        {
            get { return key_ ?? KeyDefaultValue; }
            set
            {
                key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "key" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasKey
        {
            get { return key_ != null; }
        }
        /// <summary>Clears the value of the "key" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearKey()
        {
            key_ = null;
        }

        /// <summary>Field number for the "val" field.</summary>
        public const int ValFieldNumber = 2;
        private readonly static string ValDefaultValue = "";

        private string val_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Val
        {
            get { return val_ ?? ValDefaultValue; }
            set
            {
                val_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "val" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasVal
        {
            get { return val_ != null; }
        }
        /// <summary>Clears the value of the "val" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearVal()
        {
            val_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as MapFieldEntry);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MapFieldEntry other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Key != other.Key) return false;
            if (Val != other.Val) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasKey) hash ^= Key.GetHashCode();
            if (HasVal) hash ^= Val.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasVal) {
        output.WriteRawTag(18);
        output.WriteString(Val);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasKey)
            {
                output.WriteRawTag(10);
                output.WriteString(Key);
            }
            if (HasVal)
            {
                output.WriteRawTag(18);
                output.WriteString(Val);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasKey)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
            }
            if (HasVal)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Val);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MapFieldEntry other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasKey)
            {
                Key = other.Key;
            }
            if (other.HasVal)
            {
                Val = other.Val;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Val = input.ReadString();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Key = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            Val = input.ReadString();
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// Used to hold backend-specific options.
    /// </summary>
    public sealed partial class BackendOptions : pb::IMessage<BackendOptions>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<BackendOptions> _parser = new pb::MessageParser<BackendOptions>(() => new BackendOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BackendOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[13]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BackendOptions()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BackendOptions(BackendOptions other) : this()
        {
            backendName_ = other.backendName_;
            option_ = other.option_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BackendOptions Clone()
        {
            return new BackendOptions(this);
        }

        /// <summary>Field number for the "backend_name" field.</summary>
        public const int BackendNameFieldNumber = 1;
        private readonly static string BackendNameDefaultValue = "";

        private string backendName_;
        /// <summary>
        /// Name of the backend that the specified options apply to.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string BackendName
        {
            get { return backendName_ ?? BackendNameDefaultValue; }
            set
            {
                backendName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "backend_name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasBackendName
        {
            get { return backendName_ != null; }
        }
        /// <summary>Clears the value of the "backend_name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearBackendName()
        {
            backendName_ = null;
        }

        /// <summary>Field number for the "option" field.</summary>
        public const int OptionFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Caffe2.MapFieldEntry> _repeated_option_codec
            = pb::FieldCodec.ForMessage(18, global::Caffe2.MapFieldEntry.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.MapFieldEntry> option_ = new pbc::RepeatedField<global::Caffe2.MapFieldEntry>();
        /// <summary>
        /// Flexible map for passing in the options.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.MapFieldEntry> Option
        {
            get { return option_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as BackendOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BackendOptions other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (BackendName != other.BackendName) return false;
            if (!option_.Equals(other.option_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasBackendName) hash ^= BackendName.GetHashCode();
            hash ^= option_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasBackendName) {
        output.WriteRawTag(10);
        output.WriteString(BackendName);
      }
      option_.WriteTo(output, _repeated_option_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasBackendName)
            {
                output.WriteRawTag(10);
                output.WriteString(BackendName);
            }
            option_.WriteTo(ref output, _repeated_option_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasBackendName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(BackendName);
            }
            size += option_.CalculateSize(_repeated_option_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BackendOptions other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasBackendName)
            {
                BackendName = other.BackendName;
            }
            option_.Add(other.option_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            BackendName = input.ReadString();
            break;
          }
          case 18: {
            option_.AddEntriesFrom(input, _repeated_option_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            BackendName = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            option_.AddEntriesFrom(ref input, _repeated_option_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// Partition definition.
    /// </summary>
    public sealed partial class PartitionInfo : pb::IMessage<PartitionInfo>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<PartitionInfo> _parser = new pb::MessageParser<PartitionInfo>(() => new PartitionInfo());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PartitionInfo> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[14]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PartitionInfo()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PartitionInfo(PartitionInfo other) : this()
        {
            name_ = other.name_;
            deviceId_ = other.deviceId_.Clone();
            extraInfo_ = other.extraInfo_;
            backendOptions_ = other.backendOptions_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PartitionInfo Clone()
        {
            return new PartitionInfo(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        /// <summary>
        /// Name of the partition.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "device_id" field.</summary>
        public const int DeviceIdFieldNumber = 2;
        private static readonly pb::FieldCodec<int> _repeated_deviceId_codec
            = pb::FieldCodec.ForInt32(16);
        private readonly pbc::RepeatedField<int> deviceId_ = new pbc::RepeatedField<int>();
        /// <summary>
        /// A list of logic device ID, indicating which devices this partition
        /// can be executed on. If empty, it means the partition won't run on
        /// device but on host CPU instead.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<int> DeviceId
        {
            get { return deviceId_; }
        }

        /// <summary>Field number for the "extra_info" field.</summary>
        public const int ExtraInfoFieldNumber = 3;
        private readonly static string ExtraInfoDefaultValue = "";

        private string extraInfo_;
        /// <summary>
        /// Extra debug info.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ExtraInfo
        {
            get { return extraInfo_ ?? ExtraInfoDefaultValue; }
            set
            {
                extraInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "extra_info" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasExtraInfo
        {
            get { return extraInfo_ != null; }
        }
        /// <summary>Clears the value of the "extra_info" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearExtraInfo()
        {
            extraInfo_ = null;
        }

        /// <summary>Field number for the "backend_options" field.</summary>
        public const int BackendOptionsFieldNumber = 4;
        private static readonly pb::FieldCodec<global::Caffe2.BackendOptions> _repeated_backendOptions_codec
            = pb::FieldCodec.ForMessage(34, global::Caffe2.BackendOptions.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.BackendOptions> backendOptions_ = new pbc::RepeatedField<global::Caffe2.BackendOptions>();
        /// <summary>
        /// Flexible map for passing options specific to a backend.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.BackendOptions> BackendOptions
        {
            get { return backendOptions_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as PartitionInfo);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PartitionInfo other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!deviceId_.Equals(other.deviceId_)) return false;
            if (ExtraInfo != other.ExtraInfo) return false;
            if (!backendOptions_.Equals(other.backendOptions_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasName) hash ^= Name.GetHashCode();
            hash ^= deviceId_.GetHashCode();
            if (HasExtraInfo) hash ^= ExtraInfo.GetHashCode();
            hash ^= backendOptions_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      deviceId_.WriteTo(output, _repeated_deviceId_codec);
      if (HasExtraInfo) {
        output.WriteRawTag(26);
        output.WriteString(ExtraInfo);
      }
      backendOptions_.WriteTo(output, _repeated_backendOptions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasName)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            deviceId_.WriteTo(ref output, _repeated_deviceId_codec);
            if (HasExtraInfo)
            {
                output.WriteRawTag(26);
                output.WriteString(ExtraInfo);
            }
            backendOptions_.WriteTo(ref output, _repeated_backendOptions_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += deviceId_.CalculateSize(_repeated_deviceId_codec);
            if (HasExtraInfo)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ExtraInfo);
            }
            size += backendOptions_.CalculateSize(_repeated_backendOptions_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PartitionInfo other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            deviceId_.Add(other.deviceId_);
            if (other.HasExtraInfo)
            {
                ExtraInfo = other.ExtraInfo;
            }
            backendOptions_.Add(other.backendOptions_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18:
          case 16: {
            deviceId_.AddEntriesFrom(input, _repeated_deviceId_codec);
            break;
          }
          case 26: {
            ExtraInfo = input.ReadString();
            break;
          }
          case 34: {
            backendOptions_.AddEntriesFrom(input, _repeated_backendOptions_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                    case 16:
                        {
                            deviceId_.AddEntriesFrom(ref input, _repeated_deviceId_codec);
                            break;
                        }
                    case 26:
                        {
                            ExtraInfo = input.ReadString();
                            break;
                        }
                    case 34:
                        {
                            backendOptions_.AddEntriesFrom(ref input, _repeated_backendOptions_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// Network definition.
    /// </summary>
    public sealed partial class NetDef : pb::IMessage<NetDef>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<NetDef> _parser = new pb::MessageParser<NetDef>(() => new NetDef());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NetDef> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[15]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NetDef()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NetDef(NetDef other) : this()
        {
            _hasBits0 = other._hasBits0;
            name_ = other.name_;
            op_ = other.op_.Clone();
            type_ = other.type_;
            numWorkers_ = other.numWorkers_;
            deviceOption_ = other.deviceOption_ != null ? other.deviceOption_.Clone() : null;
            arg_ = other.arg_.Clone();
            externalInput_ = other.externalInput_.Clone();
            externalOutput_ = other.externalOutput_.Clone();
            partitionInfo_ = other.partitionInfo_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NetDef Clone()
        {
            return new NetDef(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        /// <summary>
        /// the network's name
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "op" field.</summary>
        public const int OpFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Caffe2.OperatorDef> _repeated_op_codec
            = pb::FieldCodec.ForMessage(18, global::Caffe2.OperatorDef.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.OperatorDef> op_ = new pbc::RepeatedField<global::Caffe2.OperatorDef>();
        /// <summary>
        /// Operators that the network contains.
        /// Note: this is not named "operator" because that is a reserved word in C++.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.OperatorDef> Op
        {
            get { return op_; }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 3;
        private readonly static string TypeDefaultValue = "";

        private string type_;
        /// <summary>
        /// The type of network that the net should be run with. This routes the
        /// network instantiation to different execution modes. The default mode,
        /// "simple", runs the operators in a sequential way as the original Caffe
        /// implementation does.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type
        {
            get { return type_ ?? TypeDefaultValue; }
            set
            {
                type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasType
        {
            get { return type_ != null; }
        }
        /// <summary>Clears the value of the "type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearType()
        {
            type_ = null;
        }

        /// <summary>Field number for the "num_workers" field.</summary>
        public const int NumWorkersFieldNumber = 4;
        private readonly static int NumWorkersDefaultValue = 0;

        private int numWorkers_;
        /// <summary>
        /// the number of workers, if the operators in the network is to be carried out
        /// in parallel.
        /// Note: This is to be deprecated. Using the arg field with "num_workers" as
        /// key.
        /// Note 2: The old uses of this were never actually cleaned up
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int NumWorkers
        {
            get { if ((_hasBits0 & 1) != 0) { return numWorkers_; } else { return NumWorkersDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                numWorkers_ = value;
            }
        }
        /// <summary>Gets whether the "num_workers" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasNumWorkers
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "num_workers" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearNumWorkers()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "device_option" field.</summary>
        public const int DeviceOptionFieldNumber = 5;
        private global::Caffe2.DeviceOption deviceOption_;
        /// <summary>
        /// The device option for the network. If a network has a specific device
        /// option and one of its operators does not have it set, we will copy over the
        /// device option to the operator. This allows us to basically avoid putting
        /// device options at every operator.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.DeviceOption DeviceOption
        {
            get { return deviceOption_; }
            set
            {
                deviceOption_ = value;
            }
        }

        /// <summary>Field number for the "arg" field.</summary>
        public const int ArgFieldNumber = 6;
        private static readonly pb::FieldCodec<global::Caffe2.Argument> _repeated_arg_codec
            = pb::FieldCodec.ForMessage(50, global::Caffe2.Argument.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.Argument> arg_ = new pbc::RepeatedField<global::Caffe2.Argument>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.Argument> Arg
        {
            get { return arg_; }
        }

        /// <summary>Field number for the "external_input" field.</summary>
        public const int ExternalInputFieldNumber = 7;
        private static readonly pb::FieldCodec<string> _repeated_externalInput_codec
            = pb::FieldCodec.ForString(58);
        private readonly pbc::RepeatedField<string> externalInput_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Two optional fields to declare external input and output of a net.
        /// If these two are set, when a net is created, we will sanity check for
        /// every op whether its input is declared (either as an external input,
        /// or as an intermediate blob created by one of the ops), and sanity check
        /// if all blobs in external_output are produced.
        ///
        /// In cases of memory optimization, declaring external_input and
        /// external_output also ensures that storage of these blobs are persistent:
        /// for any blob in external_input and external_output, after a network run
        /// finishes, their content are actually the right content. Any intermediate
        /// blobs' contents may be overwritten.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> ExternalInput
        {
            get { return externalInput_; }
        }

        /// <summary>Field number for the "external_output" field.</summary>
        public const int ExternalOutputFieldNumber = 8;
        private static readonly pb::FieldCodec<string> _repeated_externalOutput_codec
            = pb::FieldCodec.ForString(66);
        private readonly pbc::RepeatedField<string> externalOutput_ = new pbc::RepeatedField<string>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> ExternalOutput
        {
            get { return externalOutput_; }
        }

        /// <summary>Field number for the "partition_info" field.</summary>
        public const int PartitionInfoFieldNumber = 9;
        private static readonly pb::FieldCodec<global::Caffe2.PartitionInfo> _repeated_partitionInfo_codec
            = pb::FieldCodec.ForMessage(74, global::Caffe2.PartitionInfo.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.PartitionInfo> partitionInfo_ = new pbc::RepeatedField<global::Caffe2.PartitionInfo>();
        /// <summary>
        /// Partitioning info, indexed by partition names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.PartitionInfo> PartitionInfo
        {
            get { return partitionInfo_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as NetDef);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NetDef other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!op_.Equals(other.op_)) return false;
            if (Type != other.Type) return false;
            if (NumWorkers != other.NumWorkers) return false;
            if (!object.Equals(DeviceOption, other.DeviceOption)) return false;
            if (!arg_.Equals(other.arg_)) return false;
            if (!externalInput_.Equals(other.externalInput_)) return false;
            if (!externalOutput_.Equals(other.externalOutput_)) return false;
            if (!partitionInfo_.Equals(other.partitionInfo_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasName) hash ^= Name.GetHashCode();
            hash ^= op_.GetHashCode();
            if (HasType) hash ^= Type.GetHashCode();
            if (HasNumWorkers) hash ^= NumWorkers.GetHashCode();
            if (deviceOption_ != null) hash ^= DeviceOption.GetHashCode();
            hash ^= arg_.GetHashCode();
            hash ^= externalInput_.GetHashCode();
            hash ^= externalOutput_.GetHashCode();
            hash ^= partitionInfo_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      op_.WriteTo(output, _repeated_op_codec);
      if (HasType) {
        output.WriteRawTag(26);
        output.WriteString(Type);
      }
      if (HasNumWorkers) {
        output.WriteRawTag(32);
        output.WriteInt32(NumWorkers);
      }
      if (deviceOption_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DeviceOption);
      }
      arg_.WriteTo(output, _repeated_arg_codec);
      externalInput_.WriteTo(output, _repeated_externalInput_codec);
      externalOutput_.WriteTo(output, _repeated_externalOutput_codec);
      partitionInfo_.WriteTo(output, _repeated_partitionInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasName)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            op_.WriteTo(ref output, _repeated_op_codec);
            if (HasType)
            {
                output.WriteRawTag(26);
                output.WriteString(Type);
            }
            if (HasNumWorkers)
            {
                output.WriteRawTag(32);
                output.WriteInt32(NumWorkers);
            }
            if (deviceOption_ != null)
            {
                output.WriteRawTag(42);
                output.WriteMessage(DeviceOption);
            }
            arg_.WriteTo(ref output, _repeated_arg_codec);
            externalInput_.WriteTo(ref output, _repeated_externalInput_codec);
            externalOutput_.WriteTo(ref output, _repeated_externalOutput_codec);
            partitionInfo_.WriteTo(ref output, _repeated_partitionInfo_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += op_.CalculateSize(_repeated_op_codec);
            if (HasType)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
            }
            if (HasNumWorkers)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumWorkers);
            }
            if (deviceOption_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeviceOption);
            }
            size += arg_.CalculateSize(_repeated_arg_codec);
            size += externalInput_.CalculateSize(_repeated_externalInput_codec);
            size += externalOutput_.CalculateSize(_repeated_externalOutput_codec);
            size += partitionInfo_.CalculateSize(_repeated_partitionInfo_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NetDef other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            op_.Add(other.op_);
            if (other.HasType)
            {
                Type = other.Type;
            }
            if (other.HasNumWorkers)
            {
                NumWorkers = other.NumWorkers;
            }
            if (other.deviceOption_ != null)
            {
                if (deviceOption_ == null)
                {
                    DeviceOption = new global::Caffe2.DeviceOption();
                }
                DeviceOption.MergeFrom(other.DeviceOption);
            }
            arg_.Add(other.arg_);
            externalInput_.Add(other.externalInput_);
            externalOutput_.Add(other.externalOutput_);
            partitionInfo_.Add(other.partitionInfo_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            op_.AddEntriesFrom(input, _repeated_op_codec);
            break;
          }
          case 26: {
            Type = input.ReadString();
            break;
          }
          case 32: {
            NumWorkers = input.ReadInt32();
            break;
          }
          case 42: {
            if (deviceOption_ == null) {
              DeviceOption = new global::Caffe2.DeviceOption();
            }
            input.ReadMessage(DeviceOption);
            break;
          }
          case 50: {
            arg_.AddEntriesFrom(input, _repeated_arg_codec);
            break;
          }
          case 58: {
            externalInput_.AddEntriesFrom(input, _repeated_externalInput_codec);
            break;
          }
          case 66: {
            externalOutput_.AddEntriesFrom(input, _repeated_externalOutput_codec);
            break;
          }
          case 74: {
            partitionInfo_.AddEntriesFrom(input, _repeated_partitionInfo_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            op_.AddEntriesFrom(ref input, _repeated_op_codec);
                            break;
                        }
                    case 26:
                        {
                            Type = input.ReadString();
                            break;
                        }
                    case 32:
                        {
                            NumWorkers = input.ReadInt32();
                            break;
                        }
                    case 42:
                        {
                            if (deviceOption_ == null)
                            {
                                DeviceOption = new global::Caffe2.DeviceOption();
                            }
                            input.ReadMessage(DeviceOption);
                            break;
                        }
                    case 50:
                        {
                            arg_.AddEntriesFrom(ref input, _repeated_arg_codec);
                            break;
                        }
                    case 58:
                        {
                            externalInput_.AddEntriesFrom(ref input, _repeated_externalInput_codec);
                            break;
                        }
                    case 66:
                        {
                            externalOutput_.AddEntriesFrom(ref input, _repeated_externalOutput_codec);
                            break;
                        }
                    case 74:
                        {
                            partitionInfo_.AddEntriesFrom(ref input, _repeated_partitionInfo_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// ExecutionStep is actually a sort-of-hacky way we simulate iteration right
    /// now.
    /// </summary>
    public sealed partial class ExecutionStep : pb::IMessage<ExecutionStep>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<ExecutionStep> _parser = new pb::MessageParser<ExecutionStep>(() => new ExecutionStep());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ExecutionStep> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[16]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExecutionStep()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExecutionStep(ExecutionStep other) : this()
        {
            _hasBits0 = other._hasBits0;
            name_ = other.name_;
            substep_ = other.substep_.Clone();
            network_ = other.network_.Clone();
            numIter_ = other.numIter_;
            criteriaNetwork_ = other.criteriaNetwork_;
            reportNet_ = other.reportNet_;
            reportInterval_ = other.reportInterval_;
            runEveryMs_ = other.runEveryMs_;
            concurrentSubsteps_ = other.concurrentSubsteps_;
            shouldStopBlob_ = other.shouldStopBlob_;
            onlyOnce_ = other.onlyOnce_;
            createWorkspace_ = other.createWorkspace_;
            numConcurrentInstances_ = other.numConcurrentInstances_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExecutionStep Clone()
        {
            return new ExecutionStep(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        /// <summary>
        /// ExecutionStep should either contain a set of substeps, or a set of
        /// network names to run in this execution step. They should NOT both be set
        /// at the same time.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "substep" field.</summary>
        public const int SubstepFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Caffe2.ExecutionStep> _repeated_substep_codec
            = pb::FieldCodec.ForMessage(18, global::Caffe2.ExecutionStep.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.ExecutionStep> substep_ = new pbc::RepeatedField<global::Caffe2.ExecutionStep>();
        /// <summary>
        /// An execution step could be recursive, in which it involves a set of
        /// substeps.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.ExecutionStep> Substep
        {
            get { return substep_; }
        }

        /// <summary>Field number for the "network" field.</summary>
        public const int NetworkFieldNumber = 3;
        private static readonly pb::FieldCodec<string> _repeated_network_codec
            = pb::FieldCodec.ForString(26);
        private readonly pbc::RepeatedField<string> network_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Alternatively, an execution step could involve one or more networks.
        /// Note that you cannot have both substeps and networks. Choose one.
        /// Note that an execution step refers networks by their name. The actual
        /// network definition of the same name should be included in the network field
        /// of the plan. The reason is that a network object might hold internal states
        /// (think of a data layer), so we want to have the same network object that
        /// multiple steps could ask to run.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Network
        {
            get { return network_; }
        }

        /// <summary>Field number for the "num_iter" field.</summary>
        public const int NumIterFieldNumber = 4;
        private readonly static long NumIterDefaultValue = 0L;

        private long numIter_;
        /// <summary>
        /// Number of iterations to run this step. The substeps or the networks
        /// specified will be run sequentially, and one sequential run is considered
        /// one iteration. If this is not set, the number of iterations is assumed to
        /// be 1.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long NumIter
        {
            get { if ((_hasBits0 & 1) != 0) { return numIter_; } else { return NumIterDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                numIter_ = value;
            }
        }
        /// <summary>Gets whether the "num_iter" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasNumIter
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "num_iter" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearNumIter()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "criteria_network" field.</summary>
        public const int CriteriaNetworkFieldNumber = 5;
        private readonly static string CriteriaNetworkDefaultValue = "";

        private string criteriaNetwork_;
        /// <summary>
        /// Criteria network specifies a single output (TensorCPU&lt;bool>) of
        /// size (1), is run on every iteration by the executor, and
        /// execution terminates when the output[0] is `false`.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CriteriaNetwork
        {
            get { return criteriaNetwork_ ?? CriteriaNetworkDefaultValue; }
            set
            {
                criteriaNetwork_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "criteria_network" field is set</summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasCriteriaNetwork
        {
            get { return criteriaNetwork_ != null; }
        }
        /// <summary>Clears the value of the "criteria_network" field</summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearCriteriaNetwork()
        {
            criteriaNetwork_ = null;
        }

        /// <summary>Field number for the "report_net" field.</summary>
        public const int ReportNetFieldNumber = 7;
        private readonly static string ReportNetDefaultValue = "";

        private string reportNet_;
        /// <summary>
        /// DEPRECATED. Use `run_every_ms`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ReportNet
        {
            get { return reportNet_ ?? ReportNetDefaultValue; }
            set
            {
                reportNet_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "report_net" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasReportNet
        {
            get { return reportNet_ != null; }
        }
        /// <summary>Clears the value of the "report_net" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearReportNet()
        {
            reportNet_ = null;
        }

        /// <summary>Field number for the "report_interval" field.</summary>
        public const int ReportIntervalFieldNumber = 8;
        private readonly static int ReportIntervalDefaultValue = 0;

        private int reportInterval_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int ReportInterval
        {
            get { if ((_hasBits0 & 4) != 0) { return reportInterval_; } else { return ReportIntervalDefaultValue; } }
            set
            {
                _hasBits0 |= 4;
                reportInterval_ = value;
            }
        }
        /// <summary>Gets whether the "report_interval" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasReportInterval
        {
            get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "report_interval" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearReportInterval()
        {
            _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "run_every_ms" field.</summary>
        public const int RunEveryMsFieldNumber = 11;
        private readonly static long RunEveryMsDefaultValue = 0L;

        private long runEveryMs_;
        /// <summary>
        /// If provided, execute this step at every time interval (in millisecs)
        /// while its sibiling execution steps execute in parallel. This step is
        /// guaranteed to run at least once after all non-interval siblings finished.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long RunEveryMs
        {
            get { if ((_hasBits0 & 16) != 0) { return runEveryMs_; } else { return RunEveryMsDefaultValue; } }
            set
            {
                _hasBits0 |= 16;
                runEveryMs_ = value;
            }
        }
        /// <summary>Gets whether the "run_every_ms" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasRunEveryMs
        {
            get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "run_every_ms" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearRunEveryMs()
        {
            _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "concurrent_substeps" field.</summary>
        public const int ConcurrentSubstepsFieldNumber = 6;
        private readonly static bool ConcurrentSubstepsDefaultValue = false;

        private bool concurrentSubsteps_;
        /// <summary>
        /// If false or not set, execute sub-steps serially.
        /// If true, execute all substeps concurrently, each one in a separate thread.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ConcurrentSubsteps
        {
            get { if ((_hasBits0 & 2) != 0) { return concurrentSubsteps_; } else { return ConcurrentSubstepsDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                concurrentSubsteps_ = value;
            }
        }
        /// <summary>Gets whether the "concurrent_substeps" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasConcurrentSubsteps
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "concurrent_substeps" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearConcurrentSubsteps()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "should_stop_blob" field.</summary>
        public const int ShouldStopBlobFieldNumber = 9;
        private readonly static string ShouldStopBlobDefaultValue = "";

        private string shouldStopBlob_;
        /// <summary>
        /// Name of a scalar boolean tensor.
        /// ES checks this blob AFTER every substeps/subnets.
        /// If specified, and the value is true, then ES will skip the rest and return
        /// immediately.
        /// This means that the report_net and the first step will always be called.
        /// Use cases:
        /// 1) the first substep stops the rest if data condition not met
        /// 2) the first substep decide which of the rest of the steps should be run.
        /// 3) external control
        ///
        /// ** It is the user's responsibility to not to put this blob in race conditions.
        /// ** For example when setting this blob in concurrent substeps
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ShouldStopBlob
        {
            get { return shouldStopBlob_ ?? ShouldStopBlobDefaultValue; }
            set
            {
                shouldStopBlob_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "should_stop_blob" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasShouldStopBlob
        {
            get { return shouldStopBlob_ != null; }
        }
        /// <summary>Clears the value of the "should_stop_blob" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearShouldStopBlob()
        {
            shouldStopBlob_ = null;
        }

        /// <summary>Field number for the "only_once" field.</summary>
        public const int OnlyOnceFieldNumber = 10;
        private readonly static bool OnlyOnceDefaultValue = false;

        private bool onlyOnce_;
        /// <summary>
        /// if only_once is true, this step will only be executed once. this ONLY takes
        /// effect when using should_stop_blob
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool OnlyOnce
        {
            get { if ((_hasBits0 & 8) != 0) { return onlyOnce_; } else { return OnlyOnceDefaultValue; } }
            set
            {
                _hasBits0 |= 8;
                onlyOnce_ = value;
            }
        }
        /// <summary>Gets whether the "only_once" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasOnlyOnce
        {
            get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "only_once" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearOnlyOnce()
        {
            _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "create_workspace" field.</summary>
        public const int CreateWorkspaceFieldNumber = 12;
        private readonly static bool CreateWorkspaceDefaultValue = false;

        private bool createWorkspace_;
        /// <summary>
        /// Whether to create a child workspace for this step.
        /// If yes, the workflow and nets are re-created every time this step is run.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CreateWorkspace
        {
            get { if ((_hasBits0 & 32) != 0) { return createWorkspace_; } else { return CreateWorkspaceDefaultValue; } }
            set
            {
                _hasBits0 |= 32;
                createWorkspace_ = value;
            }
        }
        /// <summary>Gets whether the "create_workspace" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasCreateWorkspace
        {
            get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "create_workspace" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearCreateWorkspace()
        {
            _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "num_concurrent_instances" field.</summary>
        public const int NumConcurrentInstancesFieldNumber = 13;
        private readonly static int NumConcurrentInstancesDefaultValue = 0;

        private int numConcurrentInstances_;
        /// <summary>
        /// How many copies of the children execution steps to run concurrently.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int NumConcurrentInstances
        {
            get { if ((_hasBits0 & 64) != 0) { return numConcurrentInstances_; } else { return NumConcurrentInstancesDefaultValue; } }
            set
            {
                _hasBits0 |= 64;
                numConcurrentInstances_ = value;
            }
        }
        /// <summary>Gets whether the "num_concurrent_instances" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasNumConcurrentInstances
        {
            get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "num_concurrent_instances" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearNumConcurrentInstances()
        {
            _hasBits0 &= ~64;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as ExecutionStep);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ExecutionStep other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!substep_.Equals(other.substep_)) return false;
            if (!network_.Equals(other.network_)) return false;
            if (NumIter != other.NumIter) return false;
            if (CriteriaNetwork != other.CriteriaNetwork) return false;
            if (ReportNet != other.ReportNet) return false;
            if (ReportInterval != other.ReportInterval) return false;
            if (RunEveryMs != other.RunEveryMs) return false;
            if (ConcurrentSubsteps != other.ConcurrentSubsteps) return false;
            if (ShouldStopBlob != other.ShouldStopBlob) return false;
            if (OnlyOnce != other.OnlyOnce) return false;
            if (CreateWorkspace != other.CreateWorkspace) return false;
            if (NumConcurrentInstances != other.NumConcurrentInstances) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasName) hash ^= Name.GetHashCode();
            hash ^= substep_.GetHashCode();
            hash ^= network_.GetHashCode();
            if (HasNumIter) hash ^= NumIter.GetHashCode();
            if (HasCriteriaNetwork) hash ^= CriteriaNetwork.GetHashCode();
            if (HasReportNet) hash ^= ReportNet.GetHashCode();
            if (HasReportInterval) hash ^= ReportInterval.GetHashCode();
            if (HasRunEveryMs) hash ^= RunEveryMs.GetHashCode();
            if (HasConcurrentSubsteps) hash ^= ConcurrentSubsteps.GetHashCode();
            if (HasShouldStopBlob) hash ^= ShouldStopBlob.GetHashCode();
            if (HasOnlyOnce) hash ^= OnlyOnce.GetHashCode();
            if (HasCreateWorkspace) hash ^= CreateWorkspace.GetHashCode();
            if (HasNumConcurrentInstances) hash ^= NumConcurrentInstances.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      substep_.WriteTo(output, _repeated_substep_codec);
      network_.WriteTo(output, _repeated_network_codec);
      if (HasNumIter) {
        output.WriteRawTag(32);
        output.WriteInt64(NumIter);
      }
      if (HasCriteriaNetwork) {
        output.WriteRawTag(42);
        output.WriteString(CriteriaNetwork);
      }
      if (HasConcurrentSubsteps) {
        output.WriteRawTag(48);
        output.WriteBool(ConcurrentSubsteps);
      }
      if (HasReportNet) {
        output.WriteRawTag(58);
        output.WriteString(ReportNet);
      }
      if (HasReportInterval) {
        output.WriteRawTag(64);
        output.WriteInt32(ReportInterval);
      }
      if (HasShouldStopBlob) {
        output.WriteRawTag(74);
        output.WriteString(ShouldStopBlob);
      }
      if (HasOnlyOnce) {
        output.WriteRawTag(80);
        output.WriteBool(OnlyOnce);
      }
      if (HasRunEveryMs) {
        output.WriteRawTag(88);
        output.WriteInt64(RunEveryMs);
      }
      if (HasCreateWorkspace) {
        output.WriteRawTag(96);
        output.WriteBool(CreateWorkspace);
      }
      if (HasNumConcurrentInstances) {
        output.WriteRawTag(104);
        output.WriteInt32(NumConcurrentInstances);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasName)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            substep_.WriteTo(ref output, _repeated_substep_codec);
            network_.WriteTo(ref output, _repeated_network_codec);
            if (HasNumIter)
            {
                output.WriteRawTag(32);
                output.WriteInt64(NumIter);
            }
            if (HasCriteriaNetwork)
            {
                output.WriteRawTag(42);
                output.WriteString(CriteriaNetwork);
            }
            if (HasConcurrentSubsteps)
            {
                output.WriteRawTag(48);
                output.WriteBool(ConcurrentSubsteps);
            }
            if (HasReportNet)
            {
                output.WriteRawTag(58);
                output.WriteString(ReportNet);
            }
            if (HasReportInterval)
            {
                output.WriteRawTag(64);
                output.WriteInt32(ReportInterval);
            }
            if (HasShouldStopBlob)
            {
                output.WriteRawTag(74);
                output.WriteString(ShouldStopBlob);
            }
            if (HasOnlyOnce)
            {
                output.WriteRawTag(80);
                output.WriteBool(OnlyOnce);
            }
            if (HasRunEveryMs)
            {
                output.WriteRawTag(88);
                output.WriteInt64(RunEveryMs);
            }
            if (HasCreateWorkspace)
            {
                output.WriteRawTag(96);
                output.WriteBool(CreateWorkspace);
            }
            if (HasNumConcurrentInstances)
            {
                output.WriteRawTag(104);
                output.WriteInt32(NumConcurrentInstances);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += substep_.CalculateSize(_repeated_substep_codec);
            size += network_.CalculateSize(_repeated_network_codec);
            if (HasNumIter)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(NumIter);
            }
            if (HasCriteriaNetwork)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(CriteriaNetwork);
            }
            if (HasReportNet)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ReportNet);
            }
            if (HasReportInterval)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(ReportInterval);
            }
            if (HasRunEveryMs)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(RunEveryMs);
            }
            if (HasConcurrentSubsteps)
            {
                size += 1 + 1;
            }
            if (HasShouldStopBlob)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ShouldStopBlob);
            }
            if (HasOnlyOnce)
            {
                size += 1 + 1;
            }
            if (HasCreateWorkspace)
            {
                size += 1 + 1;
            }
            if (HasNumConcurrentInstances)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumConcurrentInstances);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ExecutionStep other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            substep_.Add(other.substep_);
            network_.Add(other.network_);
            if (other.HasNumIter)
            {
                NumIter = other.NumIter;
            }
            if (other.HasCriteriaNetwork)
            {
                CriteriaNetwork = other.CriteriaNetwork;
            }
            if (other.HasReportNet)
            {
                ReportNet = other.ReportNet;
            }
            if (other.HasReportInterval)
            {
                ReportInterval = other.ReportInterval;
            }
            if (other.HasRunEveryMs)
            {
                RunEveryMs = other.RunEveryMs;
            }
            if (other.HasConcurrentSubsteps)
            {
                ConcurrentSubsteps = other.ConcurrentSubsteps;
            }
            if (other.HasShouldStopBlob)
            {
                ShouldStopBlob = other.ShouldStopBlob;
            }
            if (other.HasOnlyOnce)
            {
                OnlyOnce = other.OnlyOnce;
            }
            if (other.HasCreateWorkspace)
            {
                CreateWorkspace = other.CreateWorkspace;
            }
            if (other.HasNumConcurrentInstances)
            {
                NumConcurrentInstances = other.NumConcurrentInstances;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            substep_.AddEntriesFrom(input, _repeated_substep_codec);
            break;
          }
          case 26: {
            network_.AddEntriesFrom(input, _repeated_network_codec);
            break;
          }
          case 32: {
            NumIter = input.ReadInt64();
            break;
          }
          case 42: {
            CriteriaNetwork = input.ReadString();
            break;
          }
          case 48: {
            ConcurrentSubsteps = input.ReadBool();
            break;
          }
          case 58: {
            ReportNet = input.ReadString();
            break;
          }
          case 64: {
            ReportInterval = input.ReadInt32();
            break;
          }
          case 74: {
            ShouldStopBlob = input.ReadString();
            break;
          }
          case 80: {
            OnlyOnce = input.ReadBool();
            break;
          }
          case 88: {
            RunEveryMs = input.ReadInt64();
            break;
          }
          case 96: {
            CreateWorkspace = input.ReadBool();
            break;
          }
          case 104: {
            NumConcurrentInstances = input.ReadInt32();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            substep_.AddEntriesFrom(ref input, _repeated_substep_codec);
                            break;
                        }
                    case 26:
                        {
                            network_.AddEntriesFrom(ref input, _repeated_network_codec);
                            break;
                        }
                    case 32:
                        {
                            NumIter = input.ReadInt64();
                            break;
                        }
                    case 42:
                        {
                            CriteriaNetwork = input.ReadString();
                            break;
                        }
                    case 48:
                        {
                            ConcurrentSubsteps = input.ReadBool();
                            break;
                        }
                    case 58:
                        {
                            ReportNet = input.ReadString();
                            break;
                        }
                    case 64:
                        {
                            ReportInterval = input.ReadInt32();
                            break;
                        }
                    case 74:
                        {
                            ShouldStopBlob = input.ReadString();
                            break;
                        }
                    case 80:
                        {
                            OnlyOnce = input.ReadBool();
                            break;
                        }
                    case 88:
                        {
                            RunEveryMs = input.ReadInt64();
                            break;
                        }
                    case 96:
                        {
                            CreateWorkspace = input.ReadBool();
                            break;
                        }
                    case 104:
                        {
                            NumConcurrentInstances = input.ReadInt32();
                            break;
                        }
                }
            }
        }
#endif

    }

    public sealed partial class PlanDef : pb::IMessage<PlanDef>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<PlanDef> _parser = new pb::MessageParser<PlanDef>(() => new PlanDef());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PlanDef> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[17]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanDef()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanDef(PlanDef other) : this()
        {
            name_ = other.name_;
            network_ = other.network_.Clone();
            executionStep_ = other.executionStep_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanDef Clone()
        {
            return new PlanDef(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        /// <summary>
        /// All the networks that are used in this execution. Note that networks should
        /// be ordered in the way they are executed, i.e. for a layer in a network, all
        /// its input blobs should already have been initialized by the layers or
        /// networks defined before it.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "network" field.</summary>
        public const int NetworkFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Caffe2.NetDef> _repeated_network_codec
            = pb::FieldCodec.ForMessage(18, global::Caffe2.NetDef.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.NetDef> network_ = new pbc::RepeatedField<global::Caffe2.NetDef>();
        /// <summary>
        /// The networks that are going to be used in this plan.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.NetDef> Network
        {
            get { return network_; }
        }

        /// <summary>Field number for the "execution_step" field.</summary>
        public const int ExecutionStepFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Caffe2.ExecutionStep> _repeated_executionStep_codec
            = pb::FieldCodec.ForMessage(26, global::Caffe2.ExecutionStep.Parser);
        private readonly pbc::RepeatedField<global::Caffe2.ExecutionStep> executionStep_ = new pbc::RepeatedField<global::Caffe2.ExecutionStep>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Caffe2.ExecutionStep> ExecutionStep
        {
            get { return executionStep_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as PlanDef);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PlanDef other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!network_.Equals(other.network_)) return false;
            if (!executionStep_.Equals(other.executionStep_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasName) hash ^= Name.GetHashCode();
            hash ^= network_.GetHashCode();
            hash ^= executionStep_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      network_.WriteTo(output, _repeated_network_codec);
      executionStep_.WriteTo(output, _repeated_executionStep_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasName)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            network_.WriteTo(ref output, _repeated_network_codec);
            executionStep_.WriteTo(ref output, _repeated_executionStep_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += network_.CalculateSize(_repeated_network_codec);
            size += executionStep_.CalculateSize(_repeated_executionStep_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PlanDef other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            network_.Add(other.network_);
            executionStep_.Add(other.executionStep_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            network_.AddEntriesFrom(input, _repeated_network_codec);
            break;
          }
          case 26: {
            executionStep_.AddEntriesFrom(input, _repeated_executionStep_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            network_.AddEntriesFrom(ref input, _repeated_network_codec);
                            break;
                        }
                    case 26:
                        {
                            executionStep_.AddEntriesFrom(ref input, _repeated_executionStep_codec);
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// Protobuf format for blobs that are not Tensors. We use a key to store the
    /// type of the blob. For example for a serialized DBProto, the type should
    /// be "DBReader" and the content should be a serialized DBProto object.
    /// </summary>
    public sealed partial class BlobProto : pb::IMessage<BlobProto>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<BlobProto> _parser = new pb::MessageParser<BlobProto>(() => new BlobProto());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BlobProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[18]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlobProto()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlobProto(BlobProto other) : this()
        {
            _hasBits0 = other._hasBits0;
            name_ = other.name_;
            type_ = other.type_;
            tensor_ = other.tensor_ != null ? other.tensor_.Clone() : null;
            content_ = other.content_;
            qtensor_ = other.qtensor_ != null ? other.qtensor_.Clone() : null;
            contentNumChunks_ = other.contentNumChunks_;
            contentChunkId_ = other.contentChunkId_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlobProto Clone()
        {
            return new BlobProto(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 2;
        private readonly static string TypeDefaultValue = "";

        private string type_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type
        {
            get { return type_ ?? TypeDefaultValue; }
            set
            {
                type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasType
        {
            get { return type_ != null; }
        }
        /// <summary>Clears the value of the "type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearType()
        {
            type_ = null;
        }

        /// <summary>Field number for the "tensor" field.</summary>
        public const int TensorFieldNumber = 3;
        private global::Caffe2.TensorProto tensor_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.TensorProto Tensor
        {
            get { return tensor_; }
            set
            {
                tensor_ = value;
            }
        }

        /// <summary>Field number for the "content" field.</summary>
        public const int ContentFieldNumber = 4;
        private readonly static pb::ByteString ContentDefaultValue = pb::ByteString.Empty;

        private pb::ByteString content_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString Content
        {
            get { return content_ ?? ContentDefaultValue; }
            set
            {
                content_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "content" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasContent
        {
            get { return content_ != null; }
        }
        /// <summary>Clears the value of the "content" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearContent()
        {
            content_ = null;
        }

        /// <summary>Field number for the "qtensor" field.</summary>
        public const int QtensorFieldNumber = 5;
        private global::Caffe2.QTensorProto qtensor_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Caffe2.QTensorProto Qtensor
        {
            get { return qtensor_; }
            set
            {
                qtensor_ = value;
            }
        }

        /// <summary>Field number for the "content_num_chunks" field.</summary>
        public const int ContentNumChunksFieldNumber = 6;
        private readonly static int ContentNumChunksDefaultValue = 0;

        private int contentNumChunks_;
        /// <summary>
        /// If blob is not Tensor and is divided into chunks, content_num_chunks
        /// contains number of chunks, into which blob was divided.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int ContentNumChunks
        {
            get { if ((_hasBits0 & 1) != 0) { return contentNumChunks_; } else { return ContentNumChunksDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                contentNumChunks_ = value;
            }
        }
        /// <summary>Gets whether the "content_num_chunks" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasContentNumChunks
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "content_num_chunks" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearContentNumChunks()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "content_chunk_id" field.</summary>
        public const int ContentChunkIdFieldNumber = 7;
        private readonly static int ContentChunkIdDefaultValue = 0;

        private int contentChunkId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int ContentChunkId
        {
            get { if ((_hasBits0 & 2) != 0) { return contentChunkId_; } else { return ContentChunkIdDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                contentChunkId_ = value;
            }
        }
        /// <summary>Gets whether the "content_chunk_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasContentChunkId
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "content_chunk_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearContentChunkId()
        {
            _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as BlobProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BlobProto other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (Type != other.Type) return false;
            if (!object.Equals(Tensor, other.Tensor)) return false;
            if (Content != other.Content) return false;
            if (!object.Equals(Qtensor, other.Qtensor)) return false;
            if (ContentNumChunks != other.ContentNumChunks) return false;
            if (ContentChunkId != other.ContentChunkId) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasName) hash ^= Name.GetHashCode();
            if (HasType) hash ^= Type.GetHashCode();
            if (tensor_ != null) hash ^= Tensor.GetHashCode();
            if (HasContent) hash ^= Content.GetHashCode();
            if (qtensor_ != null) hash ^= Qtensor.GetHashCode();
            if (HasContentNumChunks) hash ^= ContentNumChunks.GetHashCode();
            if (HasContentChunkId) hash ^= ContentChunkId.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasType) {
        output.WriteRawTag(18);
        output.WriteString(Type);
      }
      if (tensor_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Tensor);
      }
      if (HasContent) {
        output.WriteRawTag(34);
        output.WriteBytes(Content);
      }
      if (qtensor_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Qtensor);
      }
      if (HasContentNumChunks) {
        output.WriteRawTag(48);
        output.WriteInt32(ContentNumChunks);
      }
      if (HasContentChunkId) {
        output.WriteRawTag(56);
        output.WriteInt32(ContentChunkId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasName)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (HasType)
            {
                output.WriteRawTag(18);
                output.WriteString(Type);
            }
            if (tensor_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Tensor);
            }
            if (HasContent)
            {
                output.WriteRawTag(34);
                output.WriteBytes(Content);
            }
            if (qtensor_ != null)
            {
                output.WriteRawTag(42);
                output.WriteMessage(Qtensor);
            }
            if (HasContentNumChunks)
            {
                output.WriteRawTag(48);
                output.WriteInt32(ContentNumChunks);
            }
            if (HasContentChunkId)
            {
                output.WriteRawTag(56);
                output.WriteInt32(ContentChunkId);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (HasType)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
            }
            if (tensor_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tensor);
            }
            if (HasContent)
            {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(Content);
            }
            if (qtensor_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Qtensor);
            }
            if (HasContentNumChunks)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(ContentNumChunks);
            }
            if (HasContentChunkId)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(ContentChunkId);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BlobProto other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            if (other.HasType)
            {
                Type = other.Type;
            }
            if (other.tensor_ != null)
            {
                if (tensor_ == null)
                {
                    Tensor = new global::Caffe2.TensorProto();
                }
                Tensor.MergeFrom(other.Tensor);
            }
            if (other.HasContent)
            {
                Content = other.Content;
            }
            if (other.qtensor_ != null)
            {
                if (qtensor_ == null)
                {
                    Qtensor = new global::Caffe2.QTensorProto();
                }
                Qtensor.MergeFrom(other.Qtensor);
            }
            if (other.HasContentNumChunks)
            {
                ContentNumChunks = other.ContentNumChunks;
            }
            if (other.HasContentChunkId)
            {
                ContentChunkId = other.ContentChunkId;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Type = input.ReadString();
            break;
          }
          case 26: {
            if (tensor_ == null) {
              Tensor = new global::Caffe2.TensorProto();
            }
            input.ReadMessage(Tensor);
            break;
          }
          case 34: {
            Content = input.ReadBytes();
            break;
          }
          case 42: {
            if (qtensor_ == null) {
              Qtensor = new global::Caffe2.QTensorProto();
            }
            input.ReadMessage(Qtensor);
            break;
          }
          case 48: {
            ContentNumChunks = input.ReadInt32();
            break;
          }
          case 56: {
            ContentChunkId = input.ReadInt32();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            Type = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            if (tensor_ == null)
                            {
                                Tensor = new global::Caffe2.TensorProto();
                            }
                            input.ReadMessage(Tensor);
                            break;
                        }
                    case 34:
                        {
                            Content = input.ReadBytes();
                            break;
                        }
                    case 42:
                        {
                            if (qtensor_ == null)
                            {
                                Qtensor = new global::Caffe2.QTensorProto();
                            }
                            input.ReadMessage(Qtensor);
                            break;
                        }
                    case 48:
                        {
                            ContentNumChunks = input.ReadInt32();
                            break;
                        }
                    case 56:
                        {
                            ContentChunkId = input.ReadInt32();
                            break;
                        }
                }
            }
        }
#endif

    }

    /// <summary>
    /// Protobuf format to serialize DBReader.
    /// </summary>
    public sealed partial class DBReaderProto : pb::IMessage<DBReaderProto>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<DBReaderProto> _parser = new pb::MessageParser<DBReaderProto>(() => new DBReaderProto());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DBReaderProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::Caffe2.Caffe2Reflection.Descriptor.MessageTypes[19]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DBReaderProto()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DBReaderProto(DBReaderProto other) : this()
        {
            name_ = other.name_;
            source_ = other.source_;
            dbType_ = other.dbType_;
            key_ = other.key_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DBReaderProto Clone()
        {
            return new DBReaderProto(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        /// <summary>
        /// The name for the DB object in the workspace.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_ ?? NameDefaultValue; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName
        {
            get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName()
        {
            name_ = null;
        }

        /// <summary>Field number for the "source" field.</summary>
        public const int SourceFieldNumber = 2;
        private readonly static string SourceDefaultValue = "";

        private string source_;
        /// <summary>
        /// The source of the DB
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Source
        {
            get { return source_ ?? SourceDefaultValue; }
            set
            {
                source_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "source" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasSource
        {
            get { return source_ != null; }
        }
        /// <summary>Clears the value of the "source" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearSource()
        {
            source_ = null;
        }

        /// <summary>Field number for the "db_type" field.</summary>
        public const int DbTypeFieldNumber = 3;
        private readonly static string DbTypeDefaultValue = "";

        private string dbType_;
        /// <summary>
        /// The type of the DB
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DbType
        {
            get { return dbType_ ?? DbTypeDefaultValue; }
            set
            {
                dbType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "db_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDbType
        {
            get { return dbType_ != null; }
        }
        /// <summary>Clears the value of the "db_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDbType()
        {
            dbType_ = null;
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 4;
        private readonly static string KeyDefaultValue = "";

        private string key_;
        /// <summary>
        /// The current key of the DB if the DB supports seeking.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Key
        {
            get { return key_ ?? KeyDefaultValue; }
            set
            {
                key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "key" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasKey
        {
            get { return key_ != null; }
        }
        /// <summary>Clears the value of the "key" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearKey()
        {
            key_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as DBReaderProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DBReaderProto other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (Source != other.Source) return false;
            if (DbType != other.DbType) return false;
            if (Key != other.Key) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasName) hash ^= Name.GetHashCode();
            if (HasSource) hash ^= Source.GetHashCode();
            if (HasDbType) hash ^= DbType.GetHashCode();
            if (HasKey) hash ^= Key.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasSource) {
        output.WriteRawTag(18);
        output.WriteString(Source);
      }
      if (HasDbType) {
        output.WriteRawTag(26);
        output.WriteString(DbType);
      }
      if (HasKey) {
        output.WriteRawTag(34);
        output.WriteString(Key);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasName)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (HasSource)
            {
                output.WriteRawTag(18);
                output.WriteString(Source);
            }
            if (HasDbType)
            {
                output.WriteRawTag(26);
                output.WriteString(DbType);
            }
            if (HasKey)
            {
                output.WriteRawTag(34);
                output.WriteString(Key);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (HasName)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (HasSource)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Source);
            }
            if (HasDbType)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DbType);
            }
            if (HasKey)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DBReaderProto other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasName)
            {
                Name = other.Name;
            }
            if (other.HasSource)
            {
                Source = other.Source;
            }
            if (other.HasDbType)
            {
                DbType = other.DbType;
            }
            if (other.HasKey)
            {
                Key = other.Key;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Source = input.ReadString();
            break;
          }
          case 26: {
            DbType = input.ReadString();
            break;
          }
          case 34: {
            Key = input.ReadString();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            Source = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            DbType = input.ReadString();
                            break;
                        }
                    case 34:
                        {
                            Key = input.ReadString();
                            break;
                        }
                }
            }
        }
#endif

    }

    #endregion

}

#endregion Designer generated code
